C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE ________杓_
OBJECT MODULE PLACED IN 遥控器程序设计.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 遥控器程序设计.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          #include < reg51.h >
   2          #include < intrins.h >
   3          
   4          #define uchar unsigned char
   5          #define uint  unsigned int
   6          
   7          sbit DQ = P1^4  ;  //定义DS18B20端口DQ
   8          sbit BEEP=P1^3  ; //蜂鸣器驱动线
   9          
  10          uchar Menu_INT1=0;
  11          uchar count=0;
  12          
  13          uchar BK_count; //报警专用
  14          
  15          bit presence;
  16          bit at=0;
  17          
  18          sbit LCD_RS = P2^2 ;
  19          sbit LCD_RW = P2^3 ;
  20          sbit LCD_EN = P2^4 ;
  21          
  22          uchar code  cdis1[ ] = {"Position:model1."};
  23          uchar code  cdis2[ ] = {" WENDU:    .  C "};
  24          uchar code  cdis3[ ] = {" DS18B20  ERR0R "};
  25          uchar code  cdis4[ ] = {"  PLEASE CHECK  "};
  26          uchar code  cdis5[ ] = {"Position:model2."};
  27          uchar code  cdis6[ ] = {"Position:model3."};
  28          uchar code  cdis7[ ] = {"Position:model4."};
  29          
  30          /*************************************/
  31          
  32          sbit PT2262_Data0=P1^0;
  33          sbit PT2262_Data1=P1^1;
  34          sbit PT2262_Data2=P1^2;
  35          sbit PT2262_Data3=P1^5;
  36          sbit PT2262_TE=P1^6;            /*模式三中要置为一*/
  37          sbit System=P2^0;
  38          sbit MoveUp=P2^1;
  39          sbit MoveDown=P2^5;
  40          sbit SelfAdd=P2^6;
  41          sbit Bu_OpenUp=P3^0;
  42          sbit Bu_CloseDown=P3^1;
  43          sbit Bu_SlowlyUp=P3^4;
  44          sbit Bu_SlowlyDown=P3^5;
  45          sbit Bu_SetZero=P1^7;
  46          sbit Bu_MoveUp=P3^6;
  47          sbit Bu_MoveDown=P3^7;
  48          sbit Bu_AllowSelfControl=P2^7;
  49          sbit LED_Model1=P3^2;
  50          
  51          
  52          char key=0;
  53          uchar Button_Command;
  54          
  55          
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 2   

  56          uchar code Function0[ ]={" Happy everyday "};
  57          uchar code Function1[ ]={"    Open UP     "};
  58          uchar code Function2[ ]={"   Close Down   "};
  59          uchar code Function3[ ]={"   Slowly Up    "};
  60          uchar code Function4[ ]={"   Slowly Down  "};
  61          uchar code Function5[ ]={"  Wrong Command "};
  62          uchar code Function6[ ]={"  Self Control  "};
  63          uchar code Function7[ ]={"     Move Up    "};
  64          uchar code Function8[ ]={"    Move Down   "};
  65          uchar code Function9[ ]={"  Now,set zero  "};
  66          uchar code Function10[ ]={"AllowSelfcontrol"};
  67          uchar code Function11[ ]={"No Self control"};
  68          
  69          /************模式四专用********************/
  70          uchar code Function12[ ]={"  loading...... "};
  71          uchar code Function13[ ]={"  Sending...... "};
  72          uchar code Function14[ ]={"  Stop Sending."};
  73          uchar code Function15[ ]={"  EEPROM READY  "};
  74          uchar code Function16[ ]={"  restart......"};
  75          /*************************************/
  76          
  77          uchar code PrintString[]={"CLOCK!"};
  78          uchar code word[]={0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x20};
  79          uchar dispbuf[8],h,m,s,counter;
  80          
  81          /*******************************************************************/
  82          /*********************模式四加入的第二部分**************************/
  83          
  84          uint eeprom_address=0x2000;
  85          uchar Model4_WTime[8];
  86          uchar Model4_WTem[8];
  87          uchar Model4_RTime[9];
  88          uchar Model4_RTem[9];
  89          uchar Model4_rkey;
  90          uchar sp=0;
  91          long k=0;                               //擦出扇区计数器
  92          uint Model4_EEPROM_Address=0x2000;
  93          uchar Model4_rkey;
  94          bit Model4_SendFlag=0;          //为0允许发送，为1不允许发送（标志位）
  95          uchar Model4_Key=0;                     //模式四键盘扫描
  96          uchar m4_n;     //模式四中显示计数
  97          /****************第二次eeprom的加入********************************/
  98          uchar Model4_WTemprature[3];
  99          uint Model4_Eeprom_Counter=0x2200;
 100          
 101          bit Model4_SendFlag1=0;
 102          uint Model4_SendData_Counter=0x2200;
 103          uchar Model4_STemprature[4];
 104          uchar Cleaner=0;
 105          uint Mainaddress;
 106          
 107          uchar allow_erase=0;
 108          
 109          void Model4_Send_Data(void);
 110          void Model4_Save_Data(void);
 111          /*******************************************************************/
 112          #define ENABLE_ISP 0x80 //EEPROM操作参数设置：系统工作时钟<40MHz 时，对IAP_CONTR 寄存器设置此值
 113          
 114          sfr IAP_DATA    = 0xe2;
 115          sfr IAP_ADDRH   = 0xe3;
 116          sfr IAP_ADDRL   = 0xe4;
 117          sfr IAP_CMD     = 0xe5;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 3   

 118          sfr IAP_TRIG    = 0xe6;
 119          sfr IAP_CONTR   = 0xe7;
 120          //定义Flash 操作等待时间及允许IAP/ISP/EEPROM 操作的常数
 121          
 122          union union_temp16{unsigned int un_temp16;unsigned char un_temp8[2];}my_unTemp16;
 123          
 124          //unsigned char temp[20]="";
 125          
 126          unsigned char EEPROM_read(unsigned int add);   //读一字节，调用前需打开IAP 功能
 127          void EEPROM_write(unsigned int, unsigned char ch); //字节编程，调用前需打开IAP 功能
 128          void EEPROM_erase(unsigned int add);            //擦除扇区
 129          void EEPROM_IAP_Disable();                       //关闭IAP 功能
 130          
 131          //void save_data_to_EEPROM(unsigned char num);
 132          
 133          void send(unsigned char str[]);
 134          void lcd_pos(uchar pos);
 135          void INIT_NewTemp(void);
 136          void send_data_from_EEPROM(void);
 137          uchar Model4_ChangeForSave(uchar ucfs);
 138          //void send_data_from_EEPROM(void);
 139          void save_data_to_EEPROM(void);
 140          //void send_data_from_EEPROM(void);
 141          
 142          
 143          /*******************************************************************/
 144          /*******************************************************************/
 145          /*******************************************************************/
 146          
 147          unsigned char data  temp_data[2] = {0x00,0x00} ;
 148          unsigned char data  display[5] =   {0x00,0x00,0x00,0x00,0x00} ;
 149          unsigned char code  ditab[16] =    {0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,
 150                                                                  0x05,0x06,0x06,0x07,0x08,0x08,0x09,0x09} ;///*小数
             -位表，四舍五入*/
 151          //
 152          void beep() ;
 153          unsigned char code  mytab[8] = {0x0C,0x12,0x12,0x0C,0x00,0x00,0x00,0x00} ;
 154          
 155          #define delayNOP() ; {_nop_() ;_nop_() ;_nop_() ;_nop_() ;} ;
 156          
 157          /*******************************************************************/
 158          void delay1(int ms)
 159          {
 160   1       uchar y;
 161   1        while(ms--)
 162   1       {
 163   2        for(y = 0 ; y<250 ; y++)
 164   2        {
 165   3         _nop_();
 166   3         _nop_();
 167   3         _nop_();
 168   3         _nop_();
 169   3        }
 170   2       }
 171   1      }
 172          
 173          /******************************************************************/
 174          /*检查LCD忙状态                                                   */
 175          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。   */
 176          /******************************************************************/
 177          bit lcd_busy()
 178           {
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 4   

 179   1          bit result ;
 180   1          LCD_RS = 0 ;
 181   1          LCD_RW = 1 ;
 182   1          LCD_EN = 1 ;
 183   1          delayNOP() ;
 184   1          result = (bit)(P0&0x80) ;
 185   1          LCD_EN = 0 ;
 186   1          return(result) ;
 187   1       }
 188          
 189          /*写指令数据到LCD                                                  */
 190          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。          */
 191          /*******************************************************************/
 192          void lcd_wcmd(uchar cmd)
 193          {
 194   1         while(lcd_busy()) ;
 195   1          LCD_RS = 0 ;
 196   1          LCD_RW = 0 ;
 197   1          LCD_EN = 0 ;
 198   1          _nop_() ;
 199   1          _nop_() ;
 200   1          P0 = cmd ;
 201   1          delayNOP() ;
 202   1          LCD_EN = 1 ;
 203   1          delayNOP() ;
 204   1          LCD_EN = 0 ;
 205   1      }
 206          
 207          /*******************************************************************/
 208          /*写显示数据到LCD                            */
 209          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。       */
 210          /*******************************************************************/
 211          void lcd_wdat(uchar dat)
 212          {
 213   1         while(lcd_busy()) ;
 214   1          LCD_RS = 1 ;
 215   1          LCD_RW = 0 ;
 216   1          LCD_EN = 0 ;
 217   1          P0 = dat ;
 218   1          delayNOP() ;
 219   1          LCD_EN = 1 ;
 220   1          delayNOP() ;
 221   1          LCD_EN = 0 ;
 222   1      }
 223          
 224          
 225          /*  LCD初始化设定                                                  */
 226          /*******************************************************************/
 227          void lcd_init()
 228          {
 229   1          delay1(15) ;
 230   1          lcd_wcmd(0x01) ;      //清除LCD的显示内容
 231   1          lcd_wcmd(0x38) ;      //16*2显示，5*7点阵，8位数据
 232   1          delay1(5) ;
 233   1          lcd_wcmd(0x38) ;
 234   1          delay1(5) ;
 235   1          lcd_wcmd(0x38) ;
 236   1          delay1(5) ;
 237   1      
 238   1          lcd_wcmd(0x0c) ;      //显示开，关光标
 239   1          delay1(5) ;
 240   1          lcd_wcmd(0x06) ;      //移动光标
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 5   

 241   1          delay1(5) ;
 242   1          lcd_wcmd(0x01) ;      //清除LCD的显示内容
 243   1          delay1(5) ;
 244   1      }
 245          
 246          /*  设定显示位置                                    */
 247          /*******************************************************************/
 248          void lcd_pos(uchar pos)
 249          {
 250   1        lcd_wcmd(pos | 0x80) ;  //数据指针=80+地址变量
 251   1      }
 252          
 253          /*自定义字符写入CGRAM                                   */
 254          /*******************************************************************/
 255          void  writetab()
 256          {
 257   1          unsigned char i ;
 258   1          lcd_wcmd(0x40) ;            //写CGRAM
 259   1          for (i = 0 ; i< 8 ; i++)
 260   1          lcd_wdat(mytab[ i ]) ;
 261   1      }
 262          
 263          /*us级延时函数                                        */
 264          /*******************************************************************/
 265          
 266          void Delay(unsigned int num)
 267          {
 268   1        while( --num ) ;
 269   1      }
 270          
 271          /*初始化ds1820                                      */
 272          /*******************************************************************/
 273          Init_DS18B20(void)
 274          {
 275   1           DQ = 1 ;      //DQ复位
 276   1           Delay(8) ;    //稍做延时
 277   1      
 278   1           DQ = 0 ;      //单片机将DQ拉低
 279   1           Delay(90) ;   //精确延时 大于 480us
 280   1      
 281   1           DQ = 1 ;       //拉高总线
 282   1           Delay(8) ;
 283   1      
 284   1           presence = DQ ;    //如果=0则初始化成功 =1则初始化失败
 285   1           Delay(100) ;
 286   1           DQ = 1 ;
 287   1      
 288   1           return(presence) ; //返回信号，0=presence,1= no presence
 289   1      }
 290          
 291          
 292          /* 读一个字节                     */
 293          /*******************************************************************/
 294           ReadOneChar(void)
 295          {
 296   1      unsigned char i = 0 ;
 297   1      unsigned char dat = 0 ;
 298   1      
 299   1      for (i = 8 ; i > 0 ; i--)
 300   1        {
 301   2          DQ = 0 ; // 给脉冲信号
 302   2          dat >>= 1 ;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 6   

 303   2          DQ = 1 ; // 给脉冲信号
 304   2      
 305   2          if(DQ)
 306   2           dat |= 0x80 ;
 307   2          Delay(4) ;
 308   2        }
 309   1      
 310   1          return (dat) ;
 311   1      }
 312          
 313          /* 写一个字节                                         */
 314          /*******************************************************************/
 315           WriteOneChar(unsigned char dat)
 316          {
 317   1        unsigned char i = 0 ;
 318   1        for (i = 8 ; i > 0 ; i--)
 319   1        {
 320   2          DQ = 0 ;
 321   2          DQ = dat&0x01 ;
 322   2          Delay(5) ;
 323   2      
 324   2          DQ = 1 ;
 325   2          dat>>=1 ;
 326   2        }
 327   1      }
 328          
 329          /* 读取温度                            */
 330          /*******************************************************************/
 331           Read_Temperature(void)
 332          {
 333   1           Init_DS18B20() ;
 334   1      
 335   1           WriteOneChar(0xCC) ;  // 跳过读序号列号的操作
 336   1           WriteOneChar(0x44) ;  // 启动温度转换
 337   1      
 338   1           Init_DS18B20() ;
 339   1           WriteOneChar(0xCC) ;  //跳过读序号列号的操作
 340   1           WriteOneChar(0xBE) ;  //读取温度寄存器
 341   1      
 342   1           temp_data[0] = ReadOneChar() ;   //温度低8位
 343   1           temp_data[1] = ReadOneChar() ;   //温度高8位
 344   1      }
 345          
 346          /* 数据转换与温度显示                                              */
 347          /*******************************************************************/
 348           Disp_Temperature()
 349          {
 350   1        display[4]=temp_data[0]&0x0f ;
 351   1        display[0]=ditab[display[4]]+0x30 ;     //查表得小数位的值
 352   1      
 353   1        display[4]=((temp_data[0]&0xf0)>>4)|((temp_data[1]&0x0f)<<4) ;
 354   1        display[3]=display[4]/100+0x30 ;
 355   1        display[1]=display[4]%100 ;
 356   1        display[2]=display[1]/10+0x30 ;
 357   1        display[1]=display[1]%10+0x30 ;
 358   1      
 359   1          if(display[3]==0x30)        //高位为0，不显示
 360   1         {
 361   2           display[3]=0x20 ;
 362   2           if(display[2]==0x30)      //次高位为0，不显示
 363   2           display[2]=0x20 ;
 364   2         }
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 7   

 365   1      
 366   1           lcd_pos(0x48) ;
 367   1           lcd_wdat(display[3]) ;        //百位数显示
 368   1           lcd_pos(0x49) ;
 369   1           lcd_wdat(display[2]) ;        //十位数显示
 370   1        lcd_pos(0x4a) ;
 371   1           lcd_wdat(display[1]) ;        //个位数显示
 372   1        lcd_pos(0x4c) ;
 373   1           lcd_wdat(display[0]) ;        //小数位数显示
 374   1      }
 375          
 376          /*******************************************************************/
 377          /* 蜂鸣器响一声                 */
 378          /*******************************************************************/
 379          void beep()
 380            {
 381   1          unsigned char y ;
 382   1          for (y=0 ;y<100 ;y++)
 383   1          {
 384   2            Delay(60) ;
 385   2            BEEP=!BEEP ;                //BEEP取反
 386   2          }
 387   1          BEEP=1 ;                      //关闭蜂鸣器
 388   1       Delay(40000) ;
 389   1        }
 390          
 391          /* DS18B20 OK 显示菜单                                             */
 392          /*******************************************************************/
 393          void  Ok_Menu()
 394          {
 395   1          uchar  m ;
 396   1          lcd_init() ;                //初始化LCD
 397   1      
 398   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
 399   1           m = 0 ;
 400   1          while(cdis1[m] != '\0')
 401   1           {                         //显示字符
 402   2             lcd_wdat(cdis1[m]) ;
 403   2             m++ ;
 404   2           }
 405   1      
 406   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
 407   1           m = 0 ;
 408   1          while(cdis2[m] != '\0')
 409   1           {
 410   2             lcd_wdat(cdis2[m]) ;      //显示字符
 411   2             m++ ;
 412   2           }
 413   1      
 414   1           writetab() ;               //自定义字符写入CGRAM
 415   1           delay1(5) ;
 416   1           lcd_pos(0x4d) ;
 417   1           lcd_wdat(0x00) ;          //显示自定义字符
 418   1      }
 419          
 420          
 421          /* DS18B20 ERROR 显示菜单                             */
 422          /*******************************************************************/
 423          void  Error_Menu ()
 424          {
 425   1           uchar  m ;
 426   1           lcd_init() ;                //初始化LCD
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 8   

 427   1      
 428   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
 429   1           m = 0 ;
 430   1           while(cdis3[m] != '\0')
 431   1           {                         //显示字符
 432   2             lcd_wdat(cdis3[m]) ;
 433   2             m++ ;
 434   2           }
 435   1      
 436   1           lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
 437   1           m = 0 ;
 438   1           while(cdis4[m] != '\0')
 439   1           {
 440   2             lcd_wdat(cdis4[m]);      //显示字符
 441   2             m++ ;
 442   2           }
 443   1      }
 444          
 445          
 446          
 447          
 448          
 449          
 450          /*******更新缓冲区子程序*******/
 451          void newbuf()
 452          {
 453   1       dispbuf[0]=s%10;
 454   1       dispbuf[1]=s/10;
 455   1       dispbuf[3]=m%10;
 456   1       dispbuf[4]=m/10;
 457   1       dispbuf[6]=h%10;
 458   1       dispbuf[7]=h/10;
 459   1      }
 460          
 461           
 462          
 463          /*******显示子程序**********/
 464          void disp(uchar dispadd)
 465          {
 466   1         uchar tmp;
 467   1         lcd_wcmd(dispadd);
 468   1         tmp=dispbuf[7];
 469   1         tmp=word[tmp];
 470   1         lcd_wdat(tmp);
 471   1         tmp=dispbuf[6];
 472   1         tmp=word[tmp];
 473   1         lcd_wdat(tmp);
 474   1         tmp=dispbuf[5];
 475   1         tmp=word[tmp];
 476   1         lcd_wdat(tmp);
 477   1         tmp=dispbuf[4];
 478   1         tmp=word[tmp];
 479   1         lcd_wdat(tmp);
 480   1         tmp=dispbuf[3];
 481   1         tmp=word[tmp];
 482   1         lcd_wdat(tmp);
 483   1         tmp=dispbuf[2];
 484   1         tmp=word[tmp];
 485   1         lcd_wdat(tmp);
 486   1         tmp=dispbuf[1];
 487   1         tmp=word[tmp];
 488   1         lcd_wdat(tmp);
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 9   

 489   1         tmp=dispbuf[0];
 490   1         tmp=word[tmp];
 491   1         lcd_wdat(tmp); 
 492   1      }
 493          
 494           
 495          
 496           
 497          
 498          /*********************键盘子程序***********************/
 499          
 500          
 501          
 502          /**************************************************************以下键盘扫描不再用*************************
             -************************************************/
 503          /*
 504          uchar keypro(void)
 505          {
 506            uchar scanl,scanh;
 507            P1=0xf0;
 508            if((P1&0xf0)!=0xf0)
 509            {
 510              delay1(1);
 511              if((P1&0xf0)!=0xf0)
 512              {
 513                scanl=0xfe;
 514                while((scanl&0x10)!=0)
 515                {
 516                  P1=scanl;
 517                  if((P1&0xf0)!=0xf0)
 518                  {
 519                    scanh=(P1&0xf0)|0x0f;
 520                    return (~scanh)+(~scanl);
 521                   }
 522                  else scanl=(scanl<<1)|0x01;
 523                }
 524              } 
 525            } 
 526            return 0;
 527          }
 528          */
 529          /************************************************************以上为注释掉的键盘扫描***********************
             -****************************************/
 530          
 531          
 532          
 533          
 534          
 535          /***************************************************全新键盘扫描******************************************
             -****************************************/
 536          uchar KeyScan_1(void){
 537   1      
 538   1      key=0;
 539   1      System=1;
 540   1      MoveUp=1;
 541   1      MoveDown=1;
 542   1      SelfAdd=1;
 543   1      Bu_OpenUp=1;
 544   1      Bu_CloseDown=1;
 545   1      Bu_SlowlyUp=1;
 546   1      Bu_SlowlyDown=1;
 547   1      Bu_MoveUp=1;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 10  

 548   1      Bu_MoveDown=1;
 549   1      Bu_SetZero=1;
 550   1      Bu_AllowSelfControl=1;
 551   1      
 552   1      
 553   1      if((Bu_OpenUp==1)&&(Bu_CloseDown==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(Mov
             -eDown==1)&&(SelfAdd==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1)){
 554   2      delay1(5);
 555   2      if((Bu_OpenUp==1)&&(Bu_CloseDown==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(Mov
             -eDown==1)&&(SelfAdd==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1))
 556   2      key=0;
 557   2      }
 558   1      
 559   1      
 560   1      if(Bu_OpenUp==0){
 561   2      delay1(5);
 562   2      if(Bu_OpenUp==0)
 563   2      key=1;
 564   2      while(Bu_OpenUp==0);
 565   2      }
 566   1      
 567   1      
 568   1      
 569   1      if(Bu_CloseDown==0){
 570   2      delay1(5);
 571   2      if(Bu_CloseDown==0)
 572   2      key=2;
 573   2      while(Bu_CloseDown==0);
 574   2      }
 575   1      
 576   1      
 577   1      if(Bu_SlowlyUp==0){
 578   2      delay1(5);
 579   2      if(Bu_SlowlyUp==0)
 580   2      key=3;
 581   2      while(Bu_SlowlyUp==0);
 582   2      }
 583   1      
 584   1      
 585   1      if(Bu_SlowlyDown==0){
 586   2      delay1(5);
 587   2      if(Bu_SlowlyDown==0)
 588   2      key=4;
 589   2      while(Bu_SlowlyDown==0);
 590   2      }
 591   1      
 592   1      
 593   1      if(System==0){
 594   2      delay1(5);
 595   2      if(System==0)
 596   2      key=5;
 597   2      while(System==0);
 598   2      }
 599   1      
 600   1      
 601   1      if(MoveUp==0){
 602   2      delay1(5);
 603   2      if(MoveUp==0)
 604   2      key=6;
 605   2      while(MoveUp==0);
 606   2      }
 607   1      
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 11  

 608   1      
 609   1      if(MoveDown==0){
 610   2      delay1(5);
 611   2      if(MoveDown==0)
 612   2      key=7;
 613   2      while(MoveDown==0);
 614   2      }
 615   1      
 616   1      
 617   1      if(SelfAdd==0){
 618   2      delay1(5);
 619   2      if(SelfAdd==0)
 620   2      key=8;
 621   2      while(SelfAdd==0);
 622   2      }
 623   1      
 624   1      
 625   1      if(Bu_MoveUp==0){
 626   2      delay1(5);
 627   2      if(Bu_MoveUp==0)
 628   2      key=9;
 629   2      while(Bu_MoveUp==0);
 630   2      }
 631   1      
 632   1      
 633   1      if(Bu_MoveDown==0){
 634   2      delay1(5);
 635   2      if(Bu_MoveDown==0)
 636   2      key=10;
 637   2      while(Bu_MoveDown==0);
 638   2      }
 639   1      
 640   1      
 641   1      if(Bu_SetZero==0){
 642   2      delay1(5);
 643   2      if(Bu_SetZero==0)
 644   2      key=11;
 645   2      while(Bu_SetZero==0);
 646   2      }
 647   1      
 648   1      
 649   1      if(Bu_AllowSelfControl==0){
 650   2      delay1(5);
 651   2      if(Bu_AllowSelfControl==0)
 652   2      key=12;
 653   2      while(Bu_AllowSelfControl==0);
 654   2      }
 655   1      
 656   1      
 657   1      return key;
 658   1      }
 659          
 660          /****************************************************/
 661          
 662          uchar KeyScan_2(void){
 663   1      
 664   1      key=0;
 665   1      System=1;
 666   1      MoveUp=1;
 667   1      MoveDown=1;
 668   1      SelfAdd=1;
 669   1      Bu_OpenUp=1;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 12  

 670   1      Bu_CloseDown=0;
 671   1      Bu_SlowlyUp=1;
 672   1      Bu_SlowlyDown=1;
 673   1      Bu_MoveUp=1;
 674   1      Bu_MoveDown=1;
 675   1      Bu_SetZero=1;
 676   1      Bu_AllowSelfControl=1;
 677   1      
 678   1      
 679   1      if((Bu_OpenUp==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(MoveDown==1)&&(SelfAdd
             -==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1)){
 680   2      delay1(5);
 681   2      if((Bu_OpenUp==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(MoveDown==1)&&(SelfAdd
             -==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1))
 682   2      key=0;
 683   2      }
 684   1      
 685   1      
 686   1      if(Bu_OpenUp==0){
 687   2      delay1(5);
 688   2      if(Bu_OpenUp==0)
 689   2      key=1;
 690   2      while(Bu_OpenUp==0);
 691   2      }
 692   1      
 693   1      
 694   1      /*
 695   1      if(Bu_CloseDown==0){
 696   1      delay1(5);
 697   1      if(Bu_CloseDown==0)
 698   1      key=2;
 699   1      while(Bu_CloseDown==0);
 700   1      }
 701   1      */
 702   1      
 703   1      
 704   1      if(Bu_SlowlyUp==0){
 705   2      delay1(5);
 706   2      if(Bu_SlowlyUp==0)
 707   2      key=3;
 708   2      while(Bu_SlowlyUp==0);
 709   2      }
 710   1      
 711   1      
 712   1      if(Bu_SlowlyDown==0){
 713   2      delay1(5);
 714   2      if(Bu_SlowlyDown==0)
 715   2      key=4;
 716   2      while(Bu_SlowlyDown==0);
 717   2      }
 718   1      
 719   1      
 720   1      if(System==0){
 721   2      delay1(5);
 722   2      if(System==0)
 723   2      key=5;
 724   2      while(System==0);
 725   2      }
 726   1      
 727   1      
 728   1      if(MoveUp==0){
 729   2      delay1(5);
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 13  

 730   2      if(MoveUp==0)
 731   2      key=6;
 732   2      while(MoveUp==0);
 733   2      }
 734   1      
 735   1      
 736   1      if(MoveDown==0){
 737   2      delay1(5);
 738   2      if(MoveDown==0)
 739   2      key=7;
 740   2      while(MoveDown==0);
 741   2      }
 742   1      
 743   1      
 744   1      if(SelfAdd==0){
 745   2      delay1(5);
 746   2      if(SelfAdd==0)
 747   2      key=8;
 748   2      while(SelfAdd==0);
 749   2      }
 750   1      
 751   1      
 752   1      if(Bu_MoveUp==0){
 753   2      delay1(5);
 754   2      if(Bu_MoveUp==0)
 755   2      key=9;
 756   2      while(Bu_MoveUp==0);
 757   2      }
 758   1      
 759   1      
 760   1      if(Bu_MoveDown==0){
 761   2      delay1(5);
 762   2      if(Bu_MoveDown==0)
 763   2      key=10;
 764   2      while(Bu_MoveDown==0);
 765   2      }
 766   1      
 767   1      
 768   1      if(Bu_SetZero==0){
 769   2      delay1(5);
 770   2      if(Bu_SetZero==0)
 771   2      key=11;
 772   2      while(Bu_SetZero==0);
 773   2      }
 774   1      
 775   1      
 776   1      if(Bu_AllowSelfControl==0){
 777   2      delay1(5);
 778   2      if(Bu_AllowSelfControl==0)
 779   2      key=12;
 780   2      while(Bu_AllowSelfControl==0);
 781   2      }
 782   1      
 783   1      
 784   1      return key;
 785   1      }
 786          
 787          
 788          /********************时间调整子程序********************/
 789          void adjustime()
 790          {
 791   1        uchar k;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 14  

 792   1        static uchar add;
 793   1        k=KeyScan_2();
 794   1        switch(k)
 795   1        {
 796   2         case 5: if(!at){add=0xc1;EA=0;lcd_wcmd(0xc1);lcd_wcmd
 797   3      
 798   3      (0x0f);at=1;}
 799   2                     else {lcd_wcmd(0xc0);lcd_wcmd
 800   3      
 801   3      (0x0c);at=0;EA=1;} break;
 802   2      
 803   2         case 6:  if(at)
 804   2                   {
 805   3             if(add==0xc1){add=0xc7; lcd_wcmd(add);}
 806   3                       else {add=add-3;lcd_wcmd(add);}
 807   3                     }
 808   2               break;
 809   2        
 810   2        case 7:  if(at)
 811   2                   {
 812   3                     if(add==0xc7) {add=0xc1;lcd_wcmd(add);}
 813   3                       else {add=add+3;lcd_wcmd(add);}
 814   3                 }
 815   2             break;
 816   2      
 817   2         case 8: if(at)
 818   2                  {
 819   3                    if(add==0xc1) h++;
 820   3                      if(h==24)
 821   3                h=0;
 822   3                      if(add==0xc4) m++;
 823   3               if(m==60)
 824   3                 m=0;
 825   3                      if(add==0xc7) s++;
 826   3                if(s==60)
 827   3                 s=0;
 828   3                 newbuf();
 829   3            disp(0xc0);
 830   3            lcd_wcmd(add);
 831   3                    }
 832   2                     break;
 833   2        default: break;
 834   2        }
 835   1        if(k!=0)
 836   1         {
 837   2        while((P1&0xf0)!=0xf0)
 838   2        P1=0xf0;
 839   2       }
 840   1      
 841   1      }
 842          
 843          void Self_BK_Define2(void){  
 844   1               uchar  m ;
 845   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
 846   1           m = 0 ;
 847   1          while(cdis1[m] != '\0')
 848   1           {                         //显示字符
 849   2             lcd_wdat(cdis1[m]) ;
 850   2             m++ ;
 851   2           }
 852   1      
 853   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 15  

 854   1           m = 0 ;
 855   1          while(cdis2[m] != '\0')
 856   1           {
 857   2             lcd_wdat(cdis2[m]) ;      //显示字符
 858   2             m++ ;
 859   2           }
 860   1      
 861   1           writetab() ;               //自定义字符写入CGRAM
 862   1           delay1(5) ;
 863   1           lcd_pos(0x4d) ;
 864   1           lcd_wdat(0x00) ;          //显示自定义字符
 865   1      }
 866          
 867          void Self_BK_Define1(void){    //用于时间
 868   1        uchar i=0;
 869   1        lcd_pos(0);
 870   1        while(cdis5[i]!='\0'){
 871   2        lcd_wdat(cdis5[i]);
 872   2        i++;
 873   2        }
 874   1        lcd_wcmd(0xc9);
 875   1        for(i=0;i<6;i++)
 876   1        lcd_wdat(PrintString[i]);
 877   1        lcd_wcmd(0xc0);
 878   1      }
 879          
 880          /*********************初始化子程序**********************/
 881          void init()
 882          {
 883   1        TMOD=0x21;
 884   1        TH0=0x4c;
 885   1        TL0=0x00;
 886   1         IT1=1;
 887   1              PX1=1;
 888   1        EX1=1;
 889   1              EA=1;
 890   1        ET0=1;
 891   1        TR0=1;
 892   1        counter=0;
 893   1        h=12;m=0;s=0;
 894   1        dispbuf[2]=10;
 895   1        dispbuf[5]=10;
 896   1      //  PT2262_TE=0;
 897   1      /*
 898   1      IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间 
 899   1              {       EEPROM_erase(0x2203);
 900   1                      EEPROM_erase(0x2203+0x200);
 901   1                      EEPROM_erase(0x2203+0x200+0x200);
 902   1                      EEPROM_erase(0x2203+0x200+0x200+0x200);
 903   1                      EEPROM_erase(0x2203+0x200+0x200+0x200+0x200);
 904   1                      EEPROM_erase(0x2203+0x200+0x200+0x200+0x200+0x200);
 905   1                      EEPROM_erase(0x2203+0x200+0x200+0x200+0x200+0x200+0x200);
 906   1              }
 907   1              EEPROM_IAP_Disable();
 908   1      */
 909   1      }
 910          
 911          void MainModel2(void){
 912   1      
 913   1      Bu_CloseDown=0;
 914   1      System=1;
 915   1      LED_Model1=1;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 16  

 916   1      
 917   1       Self_BK_Define1();
 918   1        while(1)
 919   1        {
 920   2         adjustime();
 921   2         if(!at)
 922   2       {
 923   3           //闪烁
 924   3            if(counter<10)        
 925   3            {
 926   4             dispbuf[2]=10;
 927   4             dispbuf[5]=10;
 928   4            }
 929   3            else
 930   3            {            
 931   4             dispbuf[2]=11;
 932   4             dispbuf[5]=11;
 933   4            }
 934   3            //更新显示缓冲区及调用显示程序
 935   3            if(counter==0)
 936   3            {
 937   4             newbuf();
 938   4             disp(0xc0);
 939   4             }
 940   3            else if(counter==10)
 941   3            disp(0xc0);  
 942   3          }
 943   2               if((((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2)||(((Menu_INT1)%4)==3))break;
 944   2         }
 945   1      /*      Bu_CloseDown=0;
 946   1         System=1;
 947   1         LED_Model1=0;
 948   1      */
 949   1      } 
 950          
 951          /*void dely500(void){
 952          
 953                  uchar i;
 954                  for(i=250;i>0;i--){_nop_();
 955                          
 956          }
 957          }
 958          */
 959          
 960          
 961          /******************************************/
 962          
 963          void delay500(void){
 964   1      
 965   1              uchar i;
 966   1              for(i=250;i>0;i--){_nop_();}
 967   1      }
 968          
 969          
 970          /*****************************************/
 971          
 972          void MainModel1(void){
 973   1       
 974   1      Self_BK_Define2();
 975   1      System=0;
 976   1      LED_Model1=1;
 977   1      Bu_CloseDown=1;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 17  

 978   1      
 979   1       do
 980   1        {
 981   2            Read_Temperature() ;
 982   2                 Disp_Temperature() ;
 983   2                              
 984   2        if(display[2]>=51){for(BK_count=200;BK_count>0;BK_count--){
 985   4        
 986   4                                      BEEP=~BEEP;
 987   4                                      delay500();  
 988   4        }
 989   3                      for(BK_count=200;BK_count>0;BK_count--){
 990   4                      
 991   4                              BEEP=~BEEP;
 992   4                              delay500();
 993   4                              delay500();
 994   4                      }
 995   3          }   
 996   2          if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==2)||(((Menu_INT1)%4)==3))break;  
 997   2      save_data_to_EEPROM();
 998   2      send_data_from_EEPROM();
 999   2          if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==2)||(((Menu_INT1)%4)==3))break;
1000   2      Model4_Save_Data();
1001   2                      
1002   2          if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==2)||(((Menu_INT1)%4)==3))break;
1003   2           }
1004   1          while(!presence);
1005   1      
1006   1           Error_Menu();
1007   1      
1008   1       do
1009   1        {
1010   2          Init_DS18B20();
1011   2          beep();
1012   2           }
1013   1       while(presence);
1014   1      /*System=1;
1015   1      LED_Model1=0;
1016   1      Bu_CloseDown=1;
1017   1      */ 
1018   1      }
1019          
1020          
1021          
1022          /**************************模块三加入******************************/
1023          /*模式三，初始化显示子函数*/
1024          /*********************************************************************************/
1025          
1026          void Self_BK_Define3(void){    //用于模式三，显示按键操作
1027   1      
1028   1              uchar  m ;
1029   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
1030   1           m = 0 ;
1031   1          while(cdis6[m]!= '\0')
1032   1           {                         //显示字符
1033   2             lcd_wdat(cdis6[m]) ;
1034   2             m++ ;
1035   2           }
1036   1      
1037   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
1038   1           m = 0 ;
1039   1          while(Function0[m] != '\0')
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 18  

1040   1           {
1041   2             lcd_wdat(Function0[m]) ;      //显示字符
1042   2             m++ ;
1043   2           }
1044   1      }
1045          
1046          
1047          /******************************************************************************/
1048          
1049          void MainModel3(void){
1050   1              uchar n;
1051   1              LED_Model1=0;
1052   1      Bu_CloseDown=1;
1053   1      System=1;
1054   1      
1055   1              Self_BK_Define3();
1056   1              delay1(1000);
1057   1              
1058   1      while(1){
1059   2      
1060   2      //  Self_BK_Define3();
1061   2              Button_Command=KeyScan_1();
1062   2                      PT2262_TE=0;
1063   2              if(Button_Command==0){//PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=1;
1064   3                      
1065   3              lcd_pos(0x40);
1066   3              n=0;
1067   3              while(Function6[n]!='\0'){
1068   4              lcd_wdat(Function6[n]);
1069   4                              n++;
1070   4                              }
1071   3      }       
1072   2      
1073   2      else if(Button_Command==1){PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=0;
1074   3                      
1075   3              lcd_pos(0x40);
1076   3              n=0;
1077   3              while(Function1[n]!='\0'){
1078   4              lcd_wdat(Function1[n]);
1079   4                              n++;
1080   4                              }
1081   3      }       
1082   2      
1083   2      else if(Button_Command==2){PT2262_Data0=0;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=0;
1084   3                      
1085   3              lcd_pos(0x40);
1086   3              n=0;
1087   3              while(Function2[n]!='\0'){
1088   4              lcd_wdat(Function2[n]);
1089   4                              n++;
1090   4                              }
1091   3      }       
1092   2      
1093   2      
1094   2      else if(Button_Command==3){PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=0;PT2262_Data3=0;
1095   3                      
1096   3              lcd_pos(0x40);
1097   3              n=0;
1098   3              while(Function3[n]!='\0'){
1099   4              lcd_wdat(Function3[n]);
1100   4                              n++;
1101   4                              }
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 19  

1102   3      }       
1103   2      
1104   2      
1105   2      else if(Button_Command==4){PT2262_Data0=0;PT2262_Data1=1;PT2262_Data2=0;PT2262_Data3=0;
1106   3                      
1107   3              lcd_pos(0x40);
1108   3              n=0;
1109   3              while(Function4[n]!='\0'){
1110   4              lcd_wdat(Function4[n]);
1111   4                              n++;
1112   4                              }
1113   3      }       
1114   2      
1115   2      
1116   2      else if(Button_Command==8){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=1;PT2262_Data3=1;
1117   3                      
1118   3              lcd_pos(0x40);
1119   3              n=0;
1120   3              while(Function11[n]!='\0'){
1121   4              lcd_wdat(Function11[n]);
1122   4                              n++;
1123   4                              }
1124   3      }       
1125   2      
1126   2      
1127   2      else if(Button_Command==9){PT2262_Data0=1;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=0;
1128   3                      
1129   3              lcd_pos(0x40);
1130   3              n=0;
1131   3              while(Function7[n]!='\0'){
1132   4              lcd_wdat(Function7[n]);
1133   4                              n++;
1134   4                              }
1135   3      }       
1136   2      
1137   2      
1138   2      else if(Button_Command==10){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=1;PT2262_Data3=0;
1139   3                      
1140   3              lcd_pos(0x40);
1141   3              n=0;
1142   3              while(Function8[n]!='\0'){
1143   4              lcd_wdat(Function8[n]);
1144   4                              n++;
1145   4                              }
1146   3      }
1147   2      
1148   2      
1149   2      else if(Button_Command==11){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=0;
1150   3                      
1151   3              lcd_pos(0x40);
1152   3              n=0;
1153   3              while(Function9[n]!='\0'){
1154   4              lcd_wdat(Function9[n]);
1155   4                              n++;
1156   4                              }
1157   3      }
1158   2      
1159   2      
1160   2      else if(Button_Command==12){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=1;
1161   3                      
1162   3              lcd_pos(0x40);
1163   3              n=0;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 20  

1164   3              while(Function10[n]!='\0'){
1165   4              lcd_wdat(Function10[n]);
1166   4                              n++;
1167   4                              }
1168   3      }
1169   2      
1170   2      
1171   2      
1172   2      else {//PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=0;
1173   3                      
1174   3              lcd_pos(0x40);
1175   3              n=0;
1176   3              while(Function5[n]!='\0'){
1177   4              lcd_wdat(Function5[n]);
1178   4                              n++;
1179   4                              }
1180   3      }       
1181   2      delay1(200);
1182   2      PT2262_TE=1;
1183   2       if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==3))break;
1184   2      }
1185   1      //LED_Model1=0;
1186   1      }//模块3最后一行
1187          
1188          
1189          
1190          
1191          /*********************************************************************************/
1192          /*
1193          void MainModel4(void)
1194          {
1195          while(1){
1196          _nop_();
1197          
1198          if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1199          }
1200          }
1201          */
1202          /*****************************************************************/
1203          /*****************************************************************/
1204          /******************************模块四加入的第一部分***************/
1205          /*****************************************************************/
1206          /*****************************************************************/
1207          unsigned char EEPROM_read(unsigned int add)      //读一字节，调用前需打开IAP 功能，入口:DPTR = 字节地址，返回:
             -A = 读出字节
1208          {
1209   1          IAP_DATA = 0x00;
1210   1          IAP_CMD = 0x01;                 //IAP/ISP/EEPROM 字节读命令
1211   1          my_unTemp16.un_temp16 = add;
1212   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
1213   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
1214   1          //EA = 0;
1215   1          IAP_TRIG = 0x46;   //   46???   先送 5Ah,再送A5h 到ISP/IAP 触发寄存器,每次都需如此
1216   1          IAP_TRIG = 0xB9;   //   B9???   送完A5h 后，ISP/IAP 命令立即被触发起动
1217   1          _nop_();
1218   1          //EA = 1;
1219   1          return (IAP_DATA);
1220   1      }
1221          
1222          
1223          void EEPROM_write(unsigned int add, unsigned char ch) //字节编程，调用前需打开IAP 功能，入口:DPTR = 字节地
             -址, A= 须编程字节的数据
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 21  

1224          {
1225   1          IAP_CMD = 0x02;                 //IAP/ISP/EEPROM 字节编程命令
1226   1          my_unTemp16.un_temp16 = add;
1227   1              IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
1228   1              IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
1229   1              IAP_DATA = ch;                  //要编程的数据先送进IAP_DATA 寄存器
1230   1              //EA = 0;
1231   1              IAP_TRIG = 0x46;   //   46???   先送 5Ah,再送A5h 到ISP/IAP 触发寄存器,每次都需如此
1232   1              IAP_TRIG = 0xB9;   //   B9???   送完A5h 后，ISP/IAP 命令立即被触发起动
1233   1          _nop_();
1234   1              //EA = 1;
1235   1      }
1236          
1237          
1238          void EEPROM_erase(unsigned int add)//擦除扇区, 入口:DPTR = 扇区地址
1239          {
1240   1              IAP_CMD = 0x03;                 //IAP/ISP/EEPROM 扇区擦除命令
1241   1          my_unTemp16.un_temp16 = add;
1242   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
1243   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
1244   1      
1245   1          //EA = 0;
1246   1          IAP_TRIG = 0x46;   //   46???   先送 5Ah,再送A5h 到ISP/IAP 触发寄存器,每次都需如此
1247   1          IAP_TRIG = 0xB9;   //   B9???   送完A5h 后，ISP/IAP 命令立即被触发起动
1248   1          _nop_();
1249   1          //EA = 1;
1250   1      }
1251          
1252          void EEPROM_IAP_Disable()
1253          {
1254   1          //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态
1255   1          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
1256   1              IAP_CONTR = 0;      //关闭IAP 功能
1257   1              IAP_CMD   = 0;      //清命令寄存器,使命令寄存器无命令,此句可不用
1258   1              IAP_TRIG = 0;      //清命令触发寄存器,使命令触发寄存器无触发,此句可不用
1259   1              IAP_ADDRH = 0;
1260   1              IAP_ADDRL = 0;
1261   1      }
1262          
1263          void send(unsigned char str[])
1264          {
1265   1              unsigned int i=0;
1266   1              while(str[i]!='\0')
1267   1              {
1268   2                      SBUF=str[i];
1269   2                      while(!TI);
1270   2                      TI=0;
1271   2                      i++;
1272   2                      }
1273   1      }
1274          /********以上为eeprom公用函数***************************/
1275          void save_data_to_EEPROM(void){
1276   1      
1277   1              uint i=0,j=0;
1278   1      
1279   1              INIT_NewTemp();
1280   1              IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
1281   1      
1282   1              while(i<8){
1283   2              EEPROM_write(eeprom_address,Model4_WTime[i]);
1284   2              eeprom_address++;
1285   2              i++;
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 22  

1286   2              k++;
1287   2      //      if((k%508)==0){disc=(0x2000+((k/511)+1)*0x200+256);EEPROM_erase(disc);}
1288   2              if(eeprom_address>(0x21ff)){eeprom_address=0x2000;k=0;
1289   3              IAP_CONTR = ENABLE_ISP; 
1290   3              EEPROM_erase(0x2000);
1291   3              EEPROM_IAP_Disable();}
1292   2              }
1293   1              while(j<8){
1294   2              EEPROM_write(eeprom_address,Model4_WTem[j]);
1295   2              eeprom_address++;
1296   2              j++;
1297   2              k++;
1298   2      //      if((k%508)==0){disc=(0x2000+((k/511)+1)*0x200+256);EEPROM_erase(disc);}
1299   2              if(eeprom_address>(0x21ff)){eeprom_address=0x2000;k=0;
1300   3              IAP_CONTR = ENABLE_ISP; 
1301   3              EEPROM_erase(0x2000);
1302   3              EEPROM_IAP_Disable();
1303   3              }
1304   2              }
1305   1              
1306   1              EEPROM_IAP_Disable(); //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态
1307   1              }
1308          
1309          void INIT_NewTemp(void){
1310   1      
1311   1      
1312   1              Model4_WTem[0]=display[3];
1313   1              Model4_WTem[1]=display[2];
1314   1              Model4_WTem[2]=display[1];
1315   1              Model4_WTem[3]='\x2E';
1316   1              Model4_WTem[4]=display[0];
1317   1              Model4_WTem[5]='\x60';
1318   1              Model4_WTem[6]='\x43';
1319   1              Model4_WTem[7]='\x20';
1320   1      
1321   1              newbuf();
1322   1              Model4_WTime[0]=Model4_ChangeForSave(dispbuf[7]);
1323   1              Model4_WTime[1]=Model4_ChangeForSave(dispbuf[6]);
1324   1              Model4_WTime[2]='\x3A'; //冒号
1325   1              Model4_WTime[3]=Model4_ChangeForSave(dispbuf[4]);
1326   1              Model4_WTime[4]=Model4_ChangeForSave(dispbuf[3]);
1327   1              Model4_WTime[5]='\x3A'; //冒号
1328   1              Model4_WTime[6]=Model4_ChangeForSave(dispbuf[1]);
1329   1              Model4_WTime[7]=Model4_ChangeForSave(dispbuf[0]);
1330   1      
1331   1              }
1332          
1333          uchar Model4_ChangeForSave(uchar ucfs){
1334   1      
1335   1              uchar tmp1;
1336   1              tmp1=ucfs;
1337   1              tmp1=word[tmp1];
1338   1              return tmp1;
1339   1      
1340   1      }
1341          
1342          void send_data_from_EEPROM(void){
1343   1      
1344   1      uchar si=0,sj=0;
1345   1      if(Model4_EEPROM_Address>0x21ff){Model4_EEPROM_Address=0x2000;}
1346   1              if(Model4_EEPROM_Address<0x21ff){
1347   2              
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 23  

1348   2                      IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
1349   2                      while(si<8){
1350   3                      Model4_RTime[si]=EEPROM_read(Model4_EEPROM_Address); 
1351   3      
1352   3                      si++;
1353   3                      Model4_EEPROM_Address++;
1354   3                      }
1355   2                      Model4_RTime[8]='\0';
1356   2              send(Model4_RTime);
1357   2              send("\x20");
1358   2      
1359   2      
1360   2              
1361   2                      while(sj<8){
1362   3                      
1363   3                              Model4_RTem[sj]=EEPROM_read(Model4_EEPROM_Address); 
1364   3                              sj++;
1365   3                              Model4_EEPROM_Address++;
1366   3              
1367   3      }
1368   2              Model4_RTem[8]='\0';
1369   2      send(Model4_RTem);
1370   2      
1371   2      send("\r\n");
1372   2      //send("\t");
1373   2      //send("\t");
1374   2      
1375   2      sp++;
1376   2      if((sp%3)==0)send("\n");
1377   2      if(sp==9)sp=0;
1378   2              }
1379   1      }
1380          
1381          /****************************模式四按键扫描*****************************************/
1382          uchar Model4_KeyScan(void){
1383   1      
1384   1      Bu_SetZero=1;                   //模式四复用：重新发送
1385   1      Bu_MoveUp=1;                            //模式四复用：开始发送信息
1386   1      Bu_MoveDown=1;                  //模式四复用：停止发送信息
1387   1      Model4_Key=0;
1388   1      
1389   1      if(Bu_MoveUp==0){
1390   2      delay1(5);
1391   2      if(Bu_MoveUp==0)
1392   2      Model4_Key=1;
1393   2      while(Bu_MoveUp==0);
1394   2      }
1395   1      
1396   1      
1397   1      if(Bu_MoveDown==0){
1398   2      delay1(5);
1399   2      if(Bu_MoveDown==0)
1400   2      Model4_Key=2;
1401   2      while(Bu_MoveDown==0);
1402   2      }
1403   1      
1404   1      
1405   1      if(Bu_SetZero==0){
1406   2      delay1(5);
1407   2      if(Bu_SetZero==0)
1408   2      Model4_Key=3;
1409   2      while(Bu_SetZero==0);
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 24  

1410   2      }
1411   1      
1412   1      return Model4_Key;      
1413   1      }
1414          
1415          void Self_BK_Define4(void){    //用于模式四，显示按键操作
1416   1      
1417   1              uchar  m ;
1418   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
1419   1           m = 0 ;
1420   1          while(cdis7[m]!= '\0')
1421   1           {                         //显示字符
1422   2             lcd_wdat(cdis7[m]) ;
1423   2             m++ ;
1424   2           }
1425   1      
1426   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
1427   1           m = 0 ;
1428   1          while(Function12[m] != '\0')
1429   1           {
1430   2             lcd_wdat(Function12[m]) ;      //显示字符
1431   2             m++ ;
1432   2           }            
1433   1      }
1434          
1435          /*********************************************************************************************************
             -**********************/
1436          /*********************************************************************************************************
             -**********************/
1437          /*******************************************第二次模式四加入**********************************************
             -**********************/
1438          /*********************************************************************************************************
             -**********************/
1439          void New_Temprature(void){
1440   1      
1441   1      Model4_WTemprature[0]=display[2];
1442   1      Model4_WTemprature[1]=display[1];
1443   1      Model4_WTemprature[2]=display[0];
1444   1      
1445   1      }
1446          
1447          void Model4_Save_Data(void){
1448   1      
1449   1              uchar M4_Wi;
1450   1              uint M4_Wj=0,disc=0;
1451   1      if(allow_erase==0){   
1452   2              for(disc=1;disc<8;disc++){
1453   3              Mainaddress=0x2000+disc*0x200;
1454   3              EEPROM_erase(Mainaddress);
1455   3      //      disc++;
1456   3              }
1457   2              EEPROM_IAP_Disable();
1458   2              allow_erase=1;
1459   2      }
1460   1      
1461   1      
1462   1              
1463   1      //      IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间 
1464   1              /*
1465   1              {       EEPROM_erase(0x2203);
1466   1                      EEPROM_erase(0x2203+0x200);
1467   1                      EEPROM_erase(0x2203+0x200+0x200);
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 25  

1468   1                      EEPROM_erase(0x2203+0x200+0x200+0x200);
1469   1                      EEPROM_erase(0x2203+0x200+0x200+0x200+0x200);
1470   1                      EEPROM_erase(0x2203+0x200+0x200+0x200+0x200+0x200);
1471   1                      EEPROM_erase(0x2203+0x200+0x200+0x200+0x200+0x200+0x200);
1472   1              }
1473   1              EEPROM_IAP_Disable();
1474   1      */      
1475   1      
1476   1      //      New_Temprature();
1477   1              
1478   1              if(Model4_Eeprom_Counter<=0x2fff){
1479   2                              New_Temprature();
1480   2                                      IAP_CONTR = ENABLE_ISP; 
1481   2                              for(M4_Wi=0;M4_Wi<=2;M4_Wi++){
1482   3                                      EEPROM_write(Model4_Eeprom_Counter,Model4_WTemprature[M4_Wi]);
1483   3      //                              EEPROM_write(Model4_Eeprom_Counter,'\x2a');
1484   3                                      Model4_Eeprom_Counter++;
1485   3      //                              M4_Wi++;
1486   3                                      M4_Wj++;
1487   3                              }       
1488   2              }
1489   1      
1490   1      else {M4_Wj=0;}
1491   1      
1492   1      //if((M4_Wj%509)==1){disc=(0x2000+((M4_Wj/511)+2)*0x200+256);EEPROM_erase(disc);}
1493   1      
1494   1      EEPROM_IAP_Disable(); //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态
1495   1      }
1496          
1497          
1498          
1499          
1500          void Model4_Send_Data(void){
1501   1      
1502   1              uchar M4_Si;//M4_Sj;
1503   1              if((Model4_SendFlag1==0)&&(Model4_SendData_Counter<0x2fff)){
1504   2                      IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
1505   2                      for(M4_Si=0;M4_Si<=2;M4_Si++){
1506   3                              Model4_STemprature[M4_Si]=EEPROM_read(Model4_SendData_Counter);
1507   3                              Model4_SendData_Counter++;
1508   3                      //      M4_Si++;
1509   3                                      
1510   3                      }
1511   2              Model4_STemprature[3]='\0';
1512   2              send(Model4_STemprature);
1513   2              send("\x20");
1514   2              Model4_rkey=Model4_KeyScan();
1515   2                      EEPROM_IAP_Disable();
1516   2              }
1517   1      
1518   1      else if(Model4_SendFlag1==0){Model4_SendFlag1=1;send("Sanding Over");}
1519   1      
1520   1      
1521   1      
1522   1      
1523   1      //send("Send Over");
1524   1                      }
1525          
1526          
1527          
1528          /*********************************************************************************************************
             -**********************/
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 26  

1529          /*********************************************************************************************************
             -**********************/
1530          
1531          
1532          
1533          void MainModel4(void){
1534   1      
1535   1      Self_BK_Define4();
1536   1      delay1(1000);
1537   1      Model4_SendData_Counter=0x2200;
1538   1      Model4_Eeprom_Counter=0x2200;
1539   1      
1540   1      while(1){
1541   2      
1542   2      Model4_rkey=Model4_KeyScan();
1543   2      
1544   2      if(Model4_rkey==1){
1545   3      while(1){//send_data_from_EEPROM();
1546   4      Model4_Send_Data();
1547   4      //send("Sending Over");
1548   4      Model4_rkey=Model4_KeyScan();
1549   4      
1550   4      if(Model4_rkey==3){Model4_SendData_Counter=0x2200;
1551   5      Model4_SendFlag1=0;
1552   5      
1553   5      lcd_pos(0x40);
1554   5              m4_n=0;
1555   5              while(Function16[m4_n]!='\0'){
1556   6              lcd_wdat(Function16[m4_n]);
1557   6                              m4_n++;
1558   6                              }
1559   5      delay1(300);
1560   5      
1561   5      }
1562   4      
1563   4      lcd_pos(0x40);
1564   4              m4_n=0;
1565   4              while(Function13[m4_n]!='\0'){
1566   5              lcd_wdat(Function13[m4_n]);
1567   5                              m4_n++;
1568   5                              }
1569   4      if((Model4_rkey==2)||(((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1570   4      //    if(((Menu_INT1)%2)==0)break;      
1571   4                              }
1572   3                              }
1573   2      
1574   2      else if(Model4_rkey==2){
1575   3      
1576   3      while(1){
1577   4      
1578   4      Model4_rkey=Model4_KeyScan();
1579   4      lcd_pos(0x40);
1580   4              m4_n=0;
1581   4              while(Function14[m4_n]!='\0'){
1582   5              lcd_wdat(Function14[m4_n]);
1583   5                              m4_n++;
1584   5                              }
1585   4      if((Model4_rkey==1)||(((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1586   4      //    if(((Menu_INT1)%2)==0)break;              
1587   4      }
1588   3                              }
1589   2      
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 27  

1590   2      
1591   2      else {
1592   3      lcd_pos(0x40);
1593   3              m4_n=0;
1594   3              while(Function15[m4_n]!='\0'){
1595   4              lcd_wdat(Function15[m4_n]);
1596   4                              m4_n++;
1597   4                              }
1598   3      }
1599   2      
1600   2      
1601   2      
1602   2      
1603   2      
1604   2      //    if(((Menu_INT1)%2)==0)break;
1605   2      if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1606   2      
1607   2      }
1608   1      }
1609          
1610          
1611          
1612          
1613          /*****************************************************************/
1614          /*****************************************************************/
1615          /*****************************************************************/
1616          /* 主函数     */
1617          /************************************/
1618          void main(void)
1619           {
1620   1              Ok_Menu();
1621   1              init();
1622   1      
1623   1      /**********************************加入的第3部分****************************************/
1624   1      /****************************************************************************************/
1625   1      SCON=0x50;//串口方式1，允许接收
1626   1         TMOD=0x21;//定时器1，定时方式2
1627   1      // TCON=0x40;//设定时器1开始计数
1628   1      //      ET1=1;
1629   1      //      EA=1;
1630   1       TR1=1;
1631   1              
1632   1         TH1=0xE8;//11.0592MHz, 1200波特率
1633   1         TL1=0xE8;
1634   1         TI=1;
1635   1         TR1=1;
1636   1              IAP_CONTR = ENABLE_ISP;
1637   1         for(Cleaner=0;Cleaner<8;Cleaner++){
1638   2              Mainaddress=0x2000+Cleaner*0x200;
1639   2              EEPROM_erase(Mainaddress);
1640   2      //      Cleaner++;
1641   2              }
1642   1              EEPROM_IAP_Disable();
1643   1      
1644   1              /************加入的第3部分结束***********************************************************/
1645   1      
1646   1              while(1){
1647   2              if(((Menu_INT1)%4)==0){
1648   3              MainModel1(); }
1649   2              else if(((Menu_INT1)%4)==1){//  init();
1650   3                      MainModel2(); }
1651   2              else if(((Menu_INT1)%4)==2){
C51 COMPILER V7.00  ________杓_                                                         11/12/2009 16:55:17 PAGE 28  

1652   3              PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=1;
1653   3              MainModel3();}
1654   2              else {MainModel4();}
1655   2      }
1656   1      }
1657          
1658                          
1659          /*************************定时器0的中断**********************/
1660          void Time0() interrupt 1 using 2    //再次强调中断子程序执行时间越短越好
1661          {
1662   1       // TH0=(65536-46075)/256;
1663   1       TH0=0x4c;
1664   1        //TL0=(65536-46075)%256;
1665   1        TL0=0x00;
1666   1        counter++;
1667   1        if(counter==20)
1668   1        {
1669   2          s++;
1670   2        counter=0;
1671   2        if(s==60)
1672   2        { 
1673   3          m++;
1674   3          s=0;
1675   3            if(m==60)
1676   3          {
1677   4            h++;
1678   4          m=0;
1679   4          if(h==24)
1680   4           h=0;
1681   4               }
1682   3             }
1683   2      
1684   2        }
1685   1      }
1686          
1687          
1688          
1689          /*外部中断*/
1690          void int1_Menu_INT1() interrupt 2  
1691                  {
1692   1                      Menu_INT1++;
1693   1                      
1694   1                      if(Menu_INT1==8)Menu_INT1=0;
1695   1              
1696   1              }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3523    ----
   CONSTANT SIZE    =    468    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     88       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
