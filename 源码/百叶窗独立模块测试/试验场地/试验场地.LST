C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE _____
OBJECT MODULE PLACED IN 试验场地.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 试验场地.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          #include < reg51.h >
   2          #include < intrins.h >
   3          
   4          #define uchar unsigned char
   5          #define uint  unsigned int
   6          
   7          sbit DQ = P1^4  ;  //定义DS18B20端口DQ
   8          sbit BEEP=P1^3  ; //蜂鸣器驱动线
   9          
  10          uchar Menu_INT1=0;
  11          uchar count=0;
  12          
  13          uchar BK_count; //报警专用
  14          
  15          bit presence;
  16          bit at=0;
  17          
  18          sbit LCD_RS = P2^2 ;
  19          sbit LCD_RW = P2^3 ;
  20          sbit LCD_EN = P2^4 ;
  21          
  22          uchar code  cdis1[ ] = {"Position:model1."};
  23          uchar code  cdis2[ ] = {" WENDU:    .  C "};
  24          uchar code  cdis3[ ] = {" DS18B20  ERR0R "};
  25          uchar code  cdis4[ ] = {"  PLEASE CHECK  "};
  26          uchar code  cdis5[ ] = {"Position:model2."};
  27          uchar code  cdis6[ ] = {"Position:model3."};
  28          uchar code  cdis7[ ] = {"Position:model4."};
  29          
  30          /*************************************/
  31          
  32          sbit PT2262_Data0=P1^0;
  33          sbit PT2262_Data1=P1^1;
  34          sbit PT2262_Data2=P1^2;
  35          sbit PT2262_Data3=P1^5;
  36          sbit PT2262_TE=P1^6;            /*模式三中要置为一*/
  37          sbit System=P2^0;
  38          sbit MoveUp=P2^1;
  39          sbit MoveDown=P2^5;
  40          sbit SelfAdd=P2^6;
  41          sbit Bu_OpenUp=P3^0;
  42          sbit Bu_CloseDown=P3^1;
  43          sbit Bu_SlowlyUp=P3^4;
  44          sbit Bu_SlowlyDown=P3^5;
  45          sbit Bu_SetZero=P1^7;
  46          sbit Bu_MoveUp=P3^6;
  47          sbit Bu_MoveDown=P3^7;
  48          sbit Bu_AllowSelfControl=P2^7;
  49          sbit LED_Model1=P3^2;
  50          
  51          
  52          char key=0;
  53          uchar Button_Command;
  54          
  55          
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 2   

  56          uchar code Function0[ ]={" Happy everyday "};
  57          uchar code Function1[ ]={"    Open UP     "};
  58          uchar code Function2[ ]={"   Close Down   "};
  59          uchar code Function3[ ]={"   Slowly Up    "};
  60          uchar code Function4[ ]={"   Slowly Down  "};
  61          uchar code Function5[ ]={"  Wrong Command "};
  62          uchar code Function6[ ]={"  Self Control  "};
  63          uchar code Function7[ ]={"     Move Up    "};
  64          uchar code Function8[ ]={"    Move Down   "};
  65          uchar code Function9[ ]={"  Now,set zero  "};
  66          uchar code Function10[ ]={"AllowSelfcontrol"};
  67          uchar code Function11[ ]={"No Self control"};
  68          
  69          /************模式四专用********************/
  70          uchar code Function12[ ]={"  loading...... "};
  71          uchar code Function13[ ]={"  Sending...... "};
  72          uchar code Function14[ ]={"  Stop Sending."};
  73          uchar code Function15[ ]={"  EEPROM READY  "};
  74          uchar code Function16[ ]={"  restart......"};
  75          /*************************************/
  76          
  77          uchar code PrintString[]={"CLOCK!"};
  78          uchar code word[]={0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x20};
  79          uchar dispbuf[8],h,m,s,counter;
  80          
  81          /*******************************************************************/
  82          /*********************模式四加入的第二部分**************************/
  83          
  84          uint eeprom_address=0x2000;
  85          uchar Model4_WTime[8];
  86          uchar Model4_WTem[8];
  87          uchar Model4_RTime[9];
  88          uchar Model4_RTem[9];
  89          uchar Model4_rkey;
  90          uchar sp=0;
  91          long k=0;                               //擦出扇区计数器
  92          uint Model4_EEPROM_Address=0x2000;
  93          uchar Model4_rkey;
  94          bit Model4_SendFlag=0;          //为0允许发送，为1不允许发送（标志位）
  95          uchar Model4_Key=0;                     //模式四键盘扫描
  96          uchar m4_n;     //模式四中显示计数
  97          
  98          /*******************************************************************/
  99          #define ENABLE_ISP 0x80 //EEPROM操作参数设置：系统工作时钟<40MHz 时，对IAP_CONTR 寄存器设置此值
 100          
 101          sfr IAP_DATA    = 0xe2;
 102          sfr IAP_ADDRH   = 0xe3;
 103          sfr IAP_ADDRL   = 0xe4;
 104          sfr IAP_CMD     = 0xe5;
 105          sfr IAP_TRIG    = 0xe6;
 106          sfr IAP_CONTR   = 0xe7;
 107          //定义Flash 操作等待时间及允许IAP/ISP/EEPROM 操作的常数
 108          
 109          union union_temp16{unsigned int un_temp16;unsigned char un_temp8[2];}my_unTemp16;
 110          
 111          //unsigned char temp[20]="";
 112          
 113          unsigned char EEPROM_read(unsigned int add);   //读一字节，调用前需打开IAP 功能
 114          void EEPROM_write(unsigned int, unsigned char ch); //字节编程，调用前需打开IAP 功能
 115          void EEPROM_erase(unsigned int add);            //擦除扇区
 116          void EEPROM_IAP_Disable();                       //关闭IAP 功能
 117          
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 3   

 118          void save_data_to_EEPROM(unsigned char num);
 119          
 120          void send(unsigned char str[]);
 121          void lcd_pos(uchar pos);
 122          void INIT_NewTemp(void);
 123          void send_data_from_EEPROM(void);
 124          uchar Model4_ChangeForSave(uchar ucfs);
 125          void send_data_from_EEPROM(void);
 126          void save_data_to_EEPROM(void);
 127          void send_data_from_EEPROM(void);
 128          
 129          /*******************************************************************/
 130          /*******************************************************************/
 131          /*******************************************************************/
 132          
 133          unsigned char data  temp_data[2] = {0x00,0x00} ;
 134          unsigned char data  display[5] =   {0x00,0x00,0x00,0x00,0x00} ;
 135          unsigned char code  ditab[16] =    {0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,
 136                                                                  0x05,0x06,0x06,0x07,0x08,0x08,0x09,0x09} ;///*小数
             -位表，四舍五入*/
 137          //
 138          void beep() ;
 139          unsigned char code  mytab[8] = {0x0C,0x12,0x12,0x0C,0x00,0x00,0x00,0x00} ;
 140          
 141          #define delayNOP() ; {_nop_() ;_nop_() ;_nop_() ;_nop_() ;} ;
 142          
 143          /*******************************************************************/
 144          void delay1(int ms)
 145          {
 146   1       uchar y;
 147   1        while(ms--)
 148   1       {
 149   2        for(y = 0 ; y<250 ; y++)
 150   2        {
 151   3         _nop_();
 152   3         _nop_();
 153   3         _nop_();
 154   3         _nop_();
 155   3        }
 156   2       }
 157   1      }
 158          
 159          /******************************************************************/
 160          /*检查LCD忙状态                                                   */
 161          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。   */
 162          /******************************************************************/
 163          bit lcd_busy()
 164           {
 165   1          bit result ;
 166   1          LCD_RS = 0 ;
 167   1          LCD_RW = 1 ;
 168   1          LCD_EN = 1 ;
 169   1          delayNOP() ;
 170   1          result = (bit)(P0&0x80) ;
 171   1          LCD_EN = 0 ;
 172   1          return(result) ;
 173   1       }
 174          
 175          /*写指令数据到LCD                                                  */
 176          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。          */
 177          /*******************************************************************/
 178          void lcd_wcmd(uchar cmd)
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 4   

 179          {
 180   1         while(lcd_busy()) ;
 181   1          LCD_RS = 0 ;
 182   1          LCD_RW = 0 ;
 183   1          LCD_EN = 0 ;
 184   1          _nop_() ;
 185   1          _nop_() ;
 186   1          P0 = cmd ;
 187   1          delayNOP() ;
 188   1          LCD_EN = 1 ;
 189   1          delayNOP() ;
 190   1          LCD_EN = 0 ;
 191   1      }
 192          
 193          /*******************************************************************/
 194          /*写显示数据到LCD                            */
 195          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。       */
 196          /*******************************************************************/
 197          void lcd_wdat(uchar dat)
 198          {
 199   1         while(lcd_busy()) ;
 200   1          LCD_RS = 1 ;
 201   1          LCD_RW = 0 ;
 202   1          LCD_EN = 0 ;
 203   1          P0 = dat ;
 204   1          delayNOP() ;
 205   1          LCD_EN = 1 ;
 206   1          delayNOP() ;
 207   1          LCD_EN = 0 ;
 208   1      }
 209          
 210          
 211          /*  LCD初始化设定                                                  */
 212          /*******************************************************************/
 213          void lcd_init()
 214          {
 215   1          delay1(15) ;
 216   1          lcd_wcmd(0x01) ;      //清除LCD的显示内容
 217   1          lcd_wcmd(0x38) ;      //16*2显示，5*7点阵，8位数据
 218   1          delay1(5) ;
 219   1          lcd_wcmd(0x38) ;
 220   1          delay1(5) ;
 221   1          lcd_wcmd(0x38) ;
 222   1          delay1(5) ;
 223   1      
 224   1          lcd_wcmd(0x0c) ;      //显示开，关光标
 225   1          delay1(5) ;
 226   1          lcd_wcmd(0x06) ;      //移动光标
 227   1          delay1(5) ;
 228   1          lcd_wcmd(0x01) ;      //清除LCD的显示内容
 229   1          delay1(5) ;
 230   1      }
 231          
 232          /*  设定显示位置                                    */
 233          /*******************************************************************/
 234          void lcd_pos(uchar pos)
 235          {
 236   1        lcd_wcmd(pos | 0x80) ;  //数据指针=80+地址变量
 237   1      }
 238          
 239          /*自定义字符写入CGRAM                                   */
 240          /*******************************************************************/
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 5   

 241          void  writetab()
 242          {
 243   1          unsigned char i ;
 244   1          lcd_wcmd(0x40) ;            //写CGRAM
 245   1          for (i = 0 ; i< 8 ; i++)
 246   1          lcd_wdat(mytab[ i ]) ;
 247   1      }
 248          
 249          /*us级延时函数                                        */
 250          /*******************************************************************/
 251          
 252          void Delay(unsigned int num)
 253          {
 254   1        while( --num ) ;
 255   1      }
 256          
 257          /*初始化ds1820                                      */
 258          /*******************************************************************/
 259          Init_DS18B20(void)
 260          {
 261   1           DQ = 1 ;      //DQ复位
 262   1           Delay(8) ;    //稍做延时
 263   1      
 264   1           DQ = 0 ;      //单片机将DQ拉低
 265   1           Delay(90) ;   //精确延时 大于 480us
 266   1      
 267   1           DQ = 1 ;       //拉高总线
 268   1           Delay(8) ;
 269   1      
 270   1           presence = DQ ;    //如果=0则初始化成功 =1则初始化失败
 271   1           Delay(100) ;
 272   1           DQ = 1 ;
 273   1      
 274   1           return(presence) ; //返回信号，0=presence,1= no presence
 275   1      }
 276          
 277          
 278          /* 读一个字节                     */
 279          /*******************************************************************/
 280           ReadOneChar(void)
 281          {
 282   1      unsigned char i = 0 ;
 283   1      unsigned char dat = 0 ;
 284   1      
 285   1      for (i = 8 ; i > 0 ; i--)
 286   1        {
 287   2          DQ = 0 ; // 给脉冲信号
 288   2          dat >>= 1 ;
 289   2          DQ = 1 ; // 给脉冲信号
 290   2      
 291   2          if(DQ)
 292   2           dat |= 0x80 ;
 293   2          Delay(4) ;
 294   2        }
 295   1      
 296   1          return (dat) ;
 297   1      }
 298          
 299          /* 写一个字节                                         */
 300          /*******************************************************************/
 301           WriteOneChar(unsigned char dat)
 302          {
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 6   

 303   1        unsigned char i = 0 ;
 304   1        for (i = 8 ; i > 0 ; i--)
 305   1        {
 306   2          DQ = 0 ;
 307   2          DQ = dat&0x01 ;
 308   2          Delay(5) ;
 309   2      
 310   2          DQ = 1 ;
 311   2          dat>>=1 ;
 312   2        }
 313   1      }
 314          
 315          /* 读取温度                            */
 316          /*******************************************************************/
 317           Read_Temperature(void)
 318          {
 319   1           Init_DS18B20() ;
 320   1      
 321   1           WriteOneChar(0xCC) ;  // 跳过读序号列号的操作
 322   1           WriteOneChar(0x44) ;  // 启动温度转换
 323   1      
 324   1           Init_DS18B20() ;
 325   1           WriteOneChar(0xCC) ;  //跳过读序号列号的操作
 326   1           WriteOneChar(0xBE) ;  //读取温度寄存器
 327   1      
 328   1           temp_data[0] = ReadOneChar() ;   //温度低8位
 329   1           temp_data[1] = ReadOneChar() ;   //温度高8位
 330   1      }
 331          
 332          /* 数据转换与温度显示                                              */
 333          /*******************************************************************/
 334           Disp_Temperature()
 335          {
 336   1        display[4]=temp_data[0]&0x0f ;
 337   1        display[0]=ditab[display[4]]+0x30 ;     //查表得小数位的值
 338   1      
 339   1        display[4]=((temp_data[0]&0xf0)>>4)|((temp_data[1]&0x0f)<<4) ;
 340   1        display[3]=display[4]/100+0x30 ;
 341   1        display[1]=display[4]%100 ;
 342   1        display[2]=display[1]/10+0x30 ;
 343   1        display[1]=display[1]%10+0x30 ;
 344   1      
 345   1          if(display[3]==0x30)        //高位为0，不显示
 346   1         {
 347   2           display[3]=0x20 ;
 348   2           if(display[2]==0x30)      //次高位为0，不显示
 349   2           display[2]=0x20 ;
 350   2         }
 351   1      
 352   1           lcd_pos(0x48) ;
 353   1           lcd_wdat(display[3]) ;        //百位数显示
 354   1           lcd_pos(0x49) ;
 355   1           lcd_wdat(display[2]) ;        //十位数显示
 356   1        lcd_pos(0x4a) ;
 357   1           lcd_wdat(display[1]) ;        //个位数显示
 358   1        lcd_pos(0x4c) ;
 359   1           lcd_wdat(display[0]) ;        //小数位数显示
 360   1      }
 361          
 362          /*******************************************************************/
 363          /* 蜂鸣器响一声                 */
 364          /*******************************************************************/
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 7   

 365          void beep()
 366            {
 367   1          unsigned char y ;
 368   1          for (y=0 ;y<100 ;y++)
 369   1          {
 370   2            Delay(60) ;
 371   2            BEEP=!BEEP ;                //BEEP取反
 372   2          }
 373   1          BEEP=1 ;                      //关闭蜂鸣器
 374   1       Delay(40000) ;
 375   1        }
 376          
 377          /* DS18B20 OK 显示菜单                                             */
 378          /*******************************************************************/
 379          void  Ok_Menu()
 380          {
 381   1          uchar  m ;
 382   1          lcd_init() ;                //初始化LCD
 383   1      
 384   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
 385   1           m = 0 ;
 386   1          while(cdis1[m] != '\0')
 387   1           {                         //显示字符
 388   2             lcd_wdat(cdis1[m]) ;
 389   2             m++ ;
 390   2           }
 391   1      
 392   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
 393   1           m = 0 ;
 394   1          while(cdis2[m] != '\0')
 395   1           {
 396   2             lcd_wdat(cdis2[m]) ;      //显示字符
 397   2             m++ ;
 398   2           }
 399   1      
 400   1           writetab() ;               //自定义字符写入CGRAM
 401   1           delay1(5) ;
 402   1           lcd_pos(0x4d) ;
 403   1           lcd_wdat(0x00) ;          //显示自定义字符
 404   1      }
 405          
 406          
 407          /* DS18B20 ERROR 显示菜单                             */
 408          /*******************************************************************/
 409          void  Error_Menu ()
 410          {
 411   1           uchar  m ;
 412   1           lcd_init() ;                //初始化LCD
 413   1      
 414   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
 415   1           m = 0 ;
 416   1           while(cdis3[m] != '\0')
 417   1           {                         //显示字符
 418   2             lcd_wdat(cdis3[m]) ;
 419   2             m++ ;
 420   2           }
 421   1      
 422   1           lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
 423   1           m = 0 ;
 424   1           while(cdis4[m] != '\0')
 425   1           {
 426   2             lcd_wdat(cdis4[m]);      //显示字符
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 8   

 427   2             m++ ;
 428   2           }
 429   1      }
 430          
 431          
 432          
 433          
 434          
 435          
 436          /*******更新缓冲区子程序*******/
 437          void newbuf()
 438          {
 439   1       dispbuf[0]=s%10;
 440   1       dispbuf[1]=s/10;
 441   1       dispbuf[3]=m%10;
 442   1       dispbuf[4]=m/10;
 443   1       dispbuf[6]=h%10;
 444   1       dispbuf[7]=h/10;
 445   1      }
 446          
 447           
 448          
 449          /*******显示子程序**********/
 450          void disp(uchar dispadd)
 451          {
 452   1         uchar tmp;
 453   1         lcd_wcmd(dispadd);
 454   1         tmp=dispbuf[7];
 455   1         tmp=word[tmp];
 456   1         lcd_wdat(tmp);
 457   1         tmp=dispbuf[6];
 458   1         tmp=word[tmp];
 459   1         lcd_wdat(tmp);
 460   1         tmp=dispbuf[5];
 461   1         tmp=word[tmp];
 462   1         lcd_wdat(tmp);
 463   1         tmp=dispbuf[4];
 464   1         tmp=word[tmp];
 465   1         lcd_wdat(tmp);
 466   1         tmp=dispbuf[3];
 467   1         tmp=word[tmp];
 468   1         lcd_wdat(tmp);
 469   1         tmp=dispbuf[2];
 470   1         tmp=word[tmp];
 471   1         lcd_wdat(tmp);
 472   1         tmp=dispbuf[1];
 473   1         tmp=word[tmp];
 474   1         lcd_wdat(tmp);
 475   1         tmp=dispbuf[0];
 476   1         tmp=word[tmp];
 477   1         lcd_wdat(tmp); 
 478   1      }
 479          
 480           
 481          
 482           
 483          
 484          /*********************键盘子程序***********************/
 485          
 486          
 487          
 488          /**************************************************************以下键盘扫描不再用*************************
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 9   

             -************************************************/
 489          /*
 490          uchar keypro(void)
 491          {
 492            uchar scanl,scanh;
 493            P1=0xf0;
 494            if((P1&0xf0)!=0xf0)
 495            {
 496              delay1(1);
 497              if((P1&0xf0)!=0xf0)
 498              {
 499                scanl=0xfe;
 500                while((scanl&0x10)!=0)
 501                {
 502                  P1=scanl;
 503                  if((P1&0xf0)!=0xf0)
 504                  {
 505                    scanh=(P1&0xf0)|0x0f;
 506                    return (~scanh)+(~scanl);
 507                   }
 508                  else scanl=(scanl<<1)|0x01;
 509                }
 510              } 
 511            } 
 512            return 0;
 513          }
 514          */
 515          /************************************************************以上为注释掉的键盘扫描***********************
             -****************************************/
 516          
 517          
 518          
 519          
 520          
 521          /***************************************************全新键盘扫描******************************************
             -****************************************/
 522          uchar KeyScan_1(void){
 523   1      
 524   1      key=0;
 525   1      System=1;
 526   1      MoveUp=1;
 527   1      MoveDown=1;
 528   1      SelfAdd=1;
 529   1      Bu_OpenUp=1;
 530   1      Bu_CloseDown=1;
 531   1      Bu_SlowlyUp=1;
 532   1      Bu_SlowlyDown=1;
 533   1      Bu_MoveUp=1;
 534   1      Bu_MoveDown=1;
 535   1      Bu_SetZero=1;
 536   1      Bu_AllowSelfControl=1;
 537   1      
 538   1      
 539   1      if((Bu_OpenUp==1)&&(Bu_CloseDown==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(Mov
             -eDown==1)&&(SelfAdd==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1)){
 540   2      delay1(5);
 541   2      if((Bu_OpenUp==1)&&(Bu_CloseDown==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(Mov
             -eDown==1)&&(SelfAdd==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1))
 542   2      key=0;
 543   2      }
 544   1      
 545   1      
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 10  

 546   1      if(Bu_OpenUp==0){
 547   2      delay1(5);
 548   2      if(Bu_OpenUp==0)
 549   2      key=1;
 550   2      while(Bu_OpenUp==0);
 551   2      }
 552   1      
 553   1      
 554   1      
 555   1      if(Bu_CloseDown==0){
 556   2      delay1(5);
 557   2      if(Bu_CloseDown==0)
 558   2      key=2;
 559   2      while(Bu_CloseDown==0);
 560   2      }
 561   1      
 562   1      
 563   1      if(Bu_SlowlyUp==0){
 564   2      delay1(5);
 565   2      if(Bu_SlowlyUp==0)
 566   2      key=3;
 567   2      while(Bu_SlowlyUp==0);
 568   2      }
 569   1      
 570   1      
 571   1      if(Bu_SlowlyDown==0){
 572   2      delay1(5);
 573   2      if(Bu_SlowlyDown==0)
 574   2      key=4;
 575   2      while(Bu_SlowlyDown==0);
 576   2      }
 577   1      
 578   1      
 579   1      if(System==0){
 580   2      delay1(5);
 581   2      if(System==0)
 582   2      key=5;
 583   2      while(System==0);
 584   2      }
 585   1      
 586   1      
 587   1      if(MoveUp==0){
 588   2      delay1(5);
 589   2      if(MoveUp==0)
 590   2      key=6;
 591   2      while(MoveUp==0);
 592   2      }
 593   1      
 594   1      
 595   1      if(MoveDown==0){
 596   2      delay1(5);
 597   2      if(MoveDown==0)
 598   2      key=7;
 599   2      while(MoveDown==0);
 600   2      }
 601   1      
 602   1      
 603   1      if(SelfAdd==0){
 604   2      delay1(5);
 605   2      if(SelfAdd==0)
 606   2      key=8;
 607   2      while(SelfAdd==0);
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 11  

 608   2      }
 609   1      
 610   1      
 611   1      if(Bu_MoveUp==0){
 612   2      delay1(5);
 613   2      if(Bu_MoveUp==0)
 614   2      key=9;
 615   2      while(Bu_MoveUp==0);
 616   2      }
 617   1      
 618   1      
 619   1      if(Bu_MoveDown==0){
 620   2      delay1(5);
 621   2      if(Bu_MoveDown==0)
 622   2      key=10;
 623   2      while(Bu_MoveDown==0);
 624   2      }
 625   1      
 626   1      
 627   1      if(Bu_SetZero==0){
 628   2      delay1(5);
 629   2      if(Bu_SetZero==0)
 630   2      key=11;
 631   2      while(Bu_SetZero==0);
 632   2      }
 633   1      
 634   1      
 635   1      if(Bu_AllowSelfControl==0){
 636   2      delay1(5);
 637   2      if(Bu_AllowSelfControl==0)
 638   2      key=12;
 639   2      while(Bu_AllowSelfControl==0);
 640   2      }
 641   1      
 642   1      
 643   1      return key;
 644   1      }
 645          
 646          /****************************************************/
 647          
 648          uchar KeyScan_2(void){
 649   1      
 650   1      key=0;
 651   1      System=1;
 652   1      MoveUp=1;
 653   1      MoveDown=1;
 654   1      SelfAdd=1;
 655   1      Bu_OpenUp=1;
 656   1      Bu_CloseDown=0;
 657   1      Bu_SlowlyUp=1;
 658   1      Bu_SlowlyDown=1;
 659   1      Bu_MoveUp=1;
 660   1      Bu_MoveDown=1;
 661   1      Bu_SetZero=1;
 662   1      Bu_AllowSelfControl=1;
 663   1      
 664   1      
 665   1      if((Bu_OpenUp==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(MoveDown==1)&&(SelfAdd
             -==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1)){
 666   2      delay1(5);
 667   2      if((Bu_OpenUp==1)&&(Bu_SlowlyUp==1)&&(Bu_SlowlyDown==1)&&(System==1)&&(MoveUp==1)&&(MoveDown==1)&&(SelfAdd
             -==1)&&(Bu_MoveUp==1)&&(Bu_MoveDown==1)&&(Bu_SetZero==1)&&(Bu_AllowSelfControl==1))
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 12  

 668   2      key=0;
 669   2      }
 670   1      
 671   1      
 672   1      if(Bu_OpenUp==0){
 673   2      delay1(5);
 674   2      if(Bu_OpenUp==0)
 675   2      key=1;
 676   2      while(Bu_OpenUp==0);
 677   2      }
 678   1      
 679   1      
 680   1      /*
 681   1      if(Bu_CloseDown==0){
 682   1      delay1(5);
 683   1      if(Bu_CloseDown==0)
 684   1      key=2;
 685   1      while(Bu_CloseDown==0);
 686   1      }
 687   1      */
 688   1      
 689   1      
 690   1      if(Bu_SlowlyUp==0){
 691   2      delay1(5);
 692   2      if(Bu_SlowlyUp==0)
 693   2      key=3;
 694   2      while(Bu_SlowlyUp==0);
 695   2      }
 696   1      
 697   1      
 698   1      if(Bu_SlowlyDown==0){
 699   2      delay1(5);
 700   2      if(Bu_SlowlyDown==0)
 701   2      key=4;
 702   2      while(Bu_SlowlyDown==0);
 703   2      }
 704   1      
 705   1      
 706   1      if(System==0){
 707   2      delay1(5);
 708   2      if(System==0)
 709   2      key=5;
 710   2      while(System==0);
 711   2      }
 712   1      
 713   1      
 714   1      if(MoveUp==0){
 715   2      delay1(5);
 716   2      if(MoveUp==0)
 717   2      key=6;
 718   2      while(MoveUp==0);
 719   2      }
 720   1      
 721   1      
 722   1      if(MoveDown==0){
 723   2      delay1(5);
 724   2      if(MoveDown==0)
 725   2      key=7;
 726   2      while(MoveDown==0);
 727   2      }
 728   1      
 729   1      
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 13  

 730   1      if(SelfAdd==0){
 731   2      delay1(5);
 732   2      if(SelfAdd==0)
 733   2      key=8;
 734   2      while(SelfAdd==0);
 735   2      }
 736   1      
 737   1      
 738   1      if(Bu_MoveUp==0){
 739   2      delay1(5);
 740   2      if(Bu_MoveUp==0)
 741   2      key=9;
 742   2      while(Bu_MoveUp==0);
 743   2      }
 744   1      
 745   1      
 746   1      if(Bu_MoveDown==0){
 747   2      delay1(5);
 748   2      if(Bu_MoveDown==0)
 749   2      key=10;
 750   2      while(Bu_MoveDown==0);
 751   2      }
 752   1      
 753   1      
 754   1      if(Bu_SetZero==0){
 755   2      delay1(5);
 756   2      if(Bu_SetZero==0)
 757   2      key=11;
 758   2      while(Bu_SetZero==0);
 759   2      }
 760   1      
 761   1      
 762   1      if(Bu_AllowSelfControl==0){
 763   2      delay1(5);
 764   2      if(Bu_AllowSelfControl==0)
 765   2      key=12;
 766   2      while(Bu_AllowSelfControl==0);
 767   2      }
 768   1      
 769   1      
 770   1      return key;
 771   1      }
 772          
 773          
 774          /********************时间调整子程序********************/
 775          void adjustime()
 776          {
 777   1        uchar k;
 778   1        static uchar add;
 779   1        k=KeyScan_2();
 780   1        switch(k)
 781   1        {
 782   2         case 5: if(!at){add=0xc1;EA=0;lcd_wcmd(0xc1);lcd_wcmd
 783   3      
 784   3      (0x0f);at=1;}
 785   2                     else {lcd_wcmd(0xc0);lcd_wcmd
 786   3      
 787   3      (0x0c);at=0;EA=1;} break;
 788   2      
 789   2         case 6:  if(at)
 790   2                   {
 791   3             if(add==0xc1){add=0xc7; lcd_wcmd(add);}
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 14  

 792   3                       else {add=add-3;lcd_wcmd(add);}
 793   3                     }
 794   2               break;
 795   2        
 796   2        case 7:  if(at)
 797   2                   {
 798   3                     if(add==0xc7) {add=0xc1;lcd_wcmd(add);}
 799   3                       else {add=add+3;lcd_wcmd(add);}
 800   3                 }
 801   2             break;
 802   2      
 803   2         case 8: if(at)
 804   2                  {
 805   3                    if(add==0xc1) h++;
 806   3                      if(h==24)
 807   3                h=0;
 808   3                      if(add==0xc4) m++;
 809   3               if(m==60)
 810   3                 m=0;
 811   3                      if(add==0xc7) s++;
 812   3                if(s==60)
 813   3                 s=0;
 814   3                 newbuf();
 815   3            disp(0xc0);
 816   3            lcd_wcmd(add);
 817   3                    }
 818   2                     break;
 819   2        default: break;
 820   2        }
 821   1        if(k!=0)
 822   1         {
 823   2        while((P1&0xf0)!=0xf0)
 824   2        P1=0xf0;
 825   2       }
 826   1      
 827   1      }
 828          
 829          void Self_BK_Define2(void){  
 830   1               uchar  m ;
 831   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
 832   1           m = 0 ;
 833   1          while(cdis1[m] != '\0')
 834   1           {                         //显示字符
 835   2             lcd_wdat(cdis1[m]) ;
 836   2             m++ ;
 837   2           }
 838   1      
 839   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
 840   1           m = 0 ;
 841   1          while(cdis2[m] != '\0')
 842   1           {
 843   2             lcd_wdat(cdis2[m]) ;      //显示字符
 844   2             m++ ;
 845   2           }
 846   1      
 847   1           writetab() ;               //自定义字符写入CGRAM
 848   1           delay1(5) ;
 849   1           lcd_pos(0x4d) ;
 850   1           lcd_wdat(0x00) ;          //显示自定义字符
 851   1      }
 852          
 853          void Self_BK_Define1(void){    //用于时间
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 15  

 854   1        uchar i=0;
 855   1        lcd_pos(0);
 856   1        while(cdis5[i]!='\0'){
 857   2        lcd_wdat(cdis5[i]);
 858   2        i++;
 859   2        }
 860   1        lcd_wcmd(0xc9);
 861   1        for(i=0;i<6;i++)
 862   1        lcd_wdat(PrintString[i]);
 863   1        lcd_wcmd(0xc0);
 864   1      }
 865          
 866          /*********************初始化子程序**********************/
 867          void init()
 868          {
 869   1        TMOD=0x21;
 870   1        TH0=0x4c;
 871   1        TL0=0x00;
 872   1         IT1=1;
 873   1              PX1=1;
 874   1        EX1=1;
 875   1              EA=1;
 876   1        ET0=1;
 877   1        TR0=1;
 878   1        counter=0;
 879   1        h=12;m=0;s=0;
 880   1        dispbuf[2]=10;
 881   1        dispbuf[5]=10;
 882   1      //  PT2262_TE=0;
 883   1      }
 884          
 885          void MainModel2(void){
 886   1      
 887   1      Bu_CloseDown=0;
 888   1      System=1;
 889   1      LED_Model1=1;
 890   1      
 891   1       Self_BK_Define1();
 892   1        while(1)
 893   1        {
 894   2         adjustime();
 895   2         if(!at)
 896   2       {
 897   3           //闪烁
 898   3            if(counter<10)        
 899   3            {
 900   4             dispbuf[2]=10;
 901   4             dispbuf[5]=10;
 902   4            }
 903   3            else
 904   3            {            
 905   4             dispbuf[2]=11;
 906   4             dispbuf[5]=11;
 907   4            }
 908   3            //更新显示缓冲区及调用显示程序
 909   3            if(counter==0)
 910   3            {
 911   4             newbuf();
 912   4             disp(0xc0);
 913   4             }
 914   3            else if(counter==10)
 915   3            disp(0xc0);  
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 16  

 916   3          }
 917   2               if((((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2)||(((Menu_INT1)%4)==3))break;
 918   2         }
 919   1      /*      Bu_CloseDown=0;
 920   1         System=1;
 921   1         LED_Model1=0;
 922   1      */
 923   1      } 
 924          
 925          /*void dely500(void){
 926          
 927                  uchar i;
 928                  for(i=250;i>0;i--){_nop_();
 929                          
 930          }
 931          }
 932          */
 933          
 934          
 935          /******************************************/
 936          
 937          void delay500(void){
 938   1      
 939   1              uchar i;
 940   1              for(i=250;i>0;i--){_nop_();}
 941   1      }
 942          
 943          
 944          /*****************************************/
 945          
 946          void MainModel1(void){
 947   1       
 948   1      Self_BK_Define2();
 949   1      System=0;
 950   1      LED_Model1=1;
 951   1      Bu_CloseDown=1;
 952   1      
 953   1       do
 954   1        {
 955   2            Read_Temperature() ;
 956   2                 Disp_Temperature() ;
 957   2                              
 958   2        if(display[2]>=51){for(BK_count=200;BK_count>0;BK_count--){
 959   4        
 960   4                                      BEEP=~BEEP;
 961   4                                      delay500();  
 962   4        }
 963   3                      for(BK_count=200;BK_count>0;BK_count--){
 964   4                      
 965   4                              BEEP=~BEEP;
 966   4                              delay500();
 967   4                              delay500();
 968   4                      }
 969   3          }   
 970   2              
 971   2      save_data_to_EEPROM();
 972   2      send_data_from_EEPROM();
 973   2                      
 974   2          if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==2)||(((Menu_INT1)%4)==3))break;
 975   2           }
 976   1          while(!presence);
 977   1      
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 17  

 978   1           Error_Menu();
 979   1      
 980   1       do
 981   1        {
 982   2          Init_DS18B20();
 983   2          beep();
 984   2           }
 985   1       while(presence);
 986   1      /*System=1;
 987   1      LED_Model1=0;
 988   1      Bu_CloseDown=1;
 989   1      */ 
 990   1      }
 991          
 992          
 993          
 994          /**************************模块三加入******************************/
 995          /*模式三，初始化显示子函数*/
 996          /*********************************************************************************/
 997          
 998          void Self_BK_Define3(void){    //用于模式三，显示按键操作
 999   1      
1000   1              uchar  m ;
1001   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
1002   1           m = 0 ;
1003   1          while(cdis6[m]!= '\0')
1004   1           {                         //显示字符
1005   2             lcd_wdat(cdis6[m]) ;
1006   2             m++ ;
1007   2           }
1008   1      
1009   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
1010   1           m = 0 ;
1011   1          while(Function0[m] != '\0')
1012   1           {
1013   2             lcd_wdat(Function0[m]) ;      //显示字符
1014   2             m++ ;
1015   2           }
1016   1      }
1017          
1018          
1019          /******************************************************************************/
1020          
1021          void MainModel3(void){
1022   1              uchar n;
1023   1              LED_Model1=0;
1024   1      Bu_CloseDown=1;
1025   1      System=1;
1026   1      
1027   1              Self_BK_Define3();
1028   1              delay1(1000);
1029   1              
1030   1      while(1){
1031   2      
1032   2      //  Self_BK_Define3();
1033   2              Button_Command=KeyScan_1();
1034   2                      PT2262_TE=0;
1035   2              if(Button_Command==0){//PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=1;
1036   3                      
1037   3              lcd_pos(0x40);
1038   3              n=0;
1039   3              while(Function6[n]!='\0'){
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 18  

1040   4              lcd_wdat(Function6[n]);
1041   4                              n++;
1042   4                              }
1043   3      }       
1044   2      
1045   2      else if(Button_Command==1){PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=0;
1046   3                      
1047   3              lcd_pos(0x40);
1048   3              n=0;
1049   3              while(Function1[n]!='\0'){
1050   4              lcd_wdat(Function1[n]);
1051   4                              n++;
1052   4                              }
1053   3      }       
1054   2      
1055   2      else if(Button_Command==2){PT2262_Data0=0;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=0;
1056   3                      
1057   3              lcd_pos(0x40);
1058   3              n=0;
1059   3              while(Function2[n]!='\0'){
1060   4              lcd_wdat(Function2[n]);
1061   4                              n++;
1062   4                              }
1063   3      }       
1064   2      
1065   2      
1066   2      else if(Button_Command==3){PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=0;PT2262_Data3=0;
1067   3                      
1068   3              lcd_pos(0x40);
1069   3              n=0;
1070   3              while(Function3[n]!='\0'){
1071   4              lcd_wdat(Function3[n]);
1072   4                              n++;
1073   4                              }
1074   3      }       
1075   2      
1076   2      
1077   2      else if(Button_Command==4){PT2262_Data0=0;PT2262_Data1=1;PT2262_Data2=0;PT2262_Data3=0;
1078   3                      
1079   3              lcd_pos(0x40);
1080   3              n=0;
1081   3              while(Function4[n]!='\0'){
1082   4              lcd_wdat(Function4[n]);
1083   4                              n++;
1084   4                              }
1085   3      }       
1086   2      
1087   2      
1088   2      else if(Button_Command==8){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=1;PT2262_Data3=1;
1089   3                      
1090   3              lcd_pos(0x40);
1091   3              n=0;
1092   3              while(Function11[n]!='\0'){
1093   4              lcd_wdat(Function11[n]);
1094   4                              n++;
1095   4                              }
1096   3      }       
1097   2      
1098   2      
1099   2      else if(Button_Command==9){PT2262_Data0=1;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=0;
1100   3                      
1101   3              lcd_pos(0x40);
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 19  

1102   3              n=0;
1103   3              while(Function7[n]!='\0'){
1104   4              lcd_wdat(Function7[n]);
1105   4                              n++;
1106   4                              }
1107   3      }       
1108   2      
1109   2      
1110   2      else if(Button_Command==10){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=1;PT2262_Data3=0;
1111   3                      
1112   3              lcd_pos(0x40);
1113   3              n=0;
1114   3              while(Function8[n]!='\0'){
1115   4              lcd_wdat(Function8[n]);
1116   4                              n++;
1117   4                              }
1118   3      }
1119   2      
1120   2      
1121   2      else if(Button_Command==11){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=0;
1122   3                      
1123   3              lcd_pos(0x40);
1124   3              n=0;
1125   3              while(Function9[n]!='\0'){
1126   4              lcd_wdat(Function9[n]);
1127   4                              n++;
1128   4                              }
1129   3      }
1130   2      
1131   2      
1132   2      else if(Button_Command==12){PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=1;
1133   3                      
1134   3              lcd_pos(0x40);
1135   3              n=0;
1136   3              while(Function10[n]!='\0'){
1137   4              lcd_wdat(Function10[n]);
1138   4                              n++;
1139   4                              }
1140   3      }
1141   2      
1142   2      
1143   2      
1144   2      else {//PT2262_Data0=0;PT2262_Data1=0;PT2262_Data2=0;PT2262_Data3=0;
1145   3                      
1146   3              lcd_pos(0x40);
1147   3              n=0;
1148   3              while(Function5[n]!='\0'){
1149   4              lcd_wdat(Function5[n]);
1150   4                              n++;
1151   4                              }
1152   3      }       
1153   2      delay1(200);
1154   2      PT2262_TE=1;
1155   2       if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==3))break;
1156   2      }
1157   1      //LED_Model1=0;
1158   1      }//模块3最后一行
1159          
1160          
1161          
1162          
1163          /*********************************************************************************/
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 20  

1164          /*
1165          void MainModel4(void)
1166          {
1167          while(1){
1168          _nop_();
1169          
1170          if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1171          }
1172          }
1173          */
1174          /*****************************************************************/
1175          /*****************************************************************/
1176          /******************************模块四加入的第一部分***************/
1177          /*****************************************************************/
1178          /*****************************************************************/
1179          unsigned char EEPROM_read(unsigned int add)      //读一字节，调用前需打开IAP 功能，入口:DPTR = 字节地址，返回:
             -A = 读出字节
1180          {
1181   1          IAP_DATA = 0x00;
1182   1          IAP_CMD = 0x01;                 //IAP/ISP/EEPROM 字节读命令
1183   1          my_unTemp16.un_temp16 = add;
1184   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
1185   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
1186   1          //EA = 0;
1187   1          IAP_TRIG = 0x46;   //   46???   先送 5Ah,再送A5h 到ISP/IAP 触发寄存器,每次都需如此
1188   1          IAP_TRIG = 0xB9;   //   B9???   送完A5h 后，ISP/IAP 命令立即被触发起动
1189   1          _nop_();
1190   1          //EA = 1;
1191   1          return (IAP_DATA);
1192   1      }
1193          
1194          
1195          void EEPROM_write(unsigned int add, unsigned char ch) //字节编程，调用前需打开IAP 功能，入口:DPTR = 字节地
             -址, A= 须编程字节的数据
1196          {
1197   1          IAP_CMD = 0x02;                 //IAP/ISP/EEPROM 字节编程命令
1198   1          my_unTemp16.un_temp16 = add;
1199   1              IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
1200   1              IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
1201   1              IAP_DATA = ch;                  //要编程的数据先送进IAP_DATA 寄存器
1202   1              //EA = 0;
1203   1              IAP_TRIG = 0x46;   //   46???   先送 5Ah,再送A5h 到ISP/IAP 触发寄存器,每次都需如此
1204   1              IAP_TRIG = 0xB9;   //   B9???   送完A5h 后，ISP/IAP 命令立即被触发起动
1205   1          _nop_();
1206   1              //EA = 1;
1207   1      }
1208          
1209          
1210          void EEPROM_erase(unsigned int add)//擦除扇区, 入口:DPTR = 扇区地址
1211          {
1212   1              IAP_CMD = 0x03;                 //IAP/ISP/EEPROM 扇区擦除命令
1213   1          my_unTemp16.un_temp16 = add;
1214   1          IAP_ADDRH = my_unTemp16.un_temp8[0];    //设置目标单元地址的高8 位地址
1215   1          IAP_ADDRL = my_unTemp16.un_temp8[1];    //设置目标单元地址的低8 位地址
1216   1      
1217   1          //EA = 0;
1218   1          IAP_TRIG = 0x46;   //   46???   先送 5Ah,再送A5h 到ISP/IAP 触发寄存器,每次都需如此
1219   1          IAP_TRIG = 0xB9;   //   B9???   送完A5h 后，ISP/IAP 命令立即被触发起动
1220   1          _nop_();
1221   1          //EA = 1;
1222   1      }
1223          
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 21  

1224          void EEPROM_IAP_Disable()
1225          {
1226   1          //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态
1227   1          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
1228   1              IAP_CONTR = 0;      //关闭IAP 功能
1229   1              IAP_CMD   = 0;      //清命令寄存器,使命令寄存器无命令,此句可不用
1230   1              IAP_TRIG = 0;      //清命令触发寄存器,使命令触发寄存器无触发,此句可不用
1231   1              IAP_ADDRH = 0;
1232   1              IAP_ADDRL = 0;
1233   1      }
1234          
1235          void send(unsigned char str[])
1236          {
1237   1              unsigned int i=0;
1238   1              while(str[i]!='\0')
1239   1              {
1240   2                      SBUF=str[i];
1241   2                      while(!TI);
1242   2                      TI=0;
1243   2                      i++;
1244   2                      }
1245   1      }
1246          /********以上为eeprom公用函数***************************/
1247          void save_data_to_EEPROM(void){
1248   1      
1249   1              uint i=0,j=0;
1250   1      
1251   1              INIT_NewTemp();
1252   1              IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
1253   1      
1254   1              while(i<8){
1255   2              EEPROM_write(eeprom_address,Model4_WTime[i]);
1256   2              eeprom_address++;
1257   2              i++;
1258   2              k++;
1259   2      //      if((k%508)==0){disc=(0x2000+((k/511)+1)*0x200+256);EEPROM_erase(disc);}
1260   2              if(eeprom_address>(0x21ff)){eeprom_address=0x2000;k=0;
1261   3              IAP_CONTR = ENABLE_ISP; 
1262   3              EEPROM_erase(0x2000);
1263   3              EEPROM_IAP_Disable();}
1264   2              }
1265   1              while(j<8){
1266   2              EEPROM_write(eeprom_address,Model4_WTem[j]);
1267   2              eeprom_address++;
1268   2              j++;
1269   2              k++;
1270   2      //      if((k%508)==0){disc=(0x2000+((k/511)+1)*0x200+256);EEPROM_erase(disc);}
1271   2              if(eeprom_address>(0x21ff)){eeprom_address=0x2000;k=0;
1272   3              IAP_CONTR = ENABLE_ISP; 
1273   3              EEPROM_erase(0x2000);
1274   3              EEPROM_IAP_Disable();
1275   3              }
1276   2              }
1277   1              
1278   1              EEPROM_IAP_Disable(); //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态
1279   1              }
1280          
1281          void INIT_NewTemp(void){
1282   1      
1283   1      
1284   1              Model4_WTem[0]=display[3];
1285   1              Model4_WTem[1]=display[2];
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 22  

1286   1              Model4_WTem[2]=display[1];
1287   1              Model4_WTem[3]='\x2E';
1288   1              Model4_WTem[4]=display[0];
1289   1              Model4_WTem[5]='\x60';
1290   1              Model4_WTem[6]='\x43';
1291   1              Model4_WTem[7]='\x20';
1292   1      
1293   1              newbuf();
1294   1              Model4_WTime[0]=Model4_ChangeForSave(dispbuf[7]);
1295   1              Model4_WTime[1]=Model4_ChangeForSave(dispbuf[6]);
1296   1              Model4_WTime[2]='\x3A'; //冒号
1297   1              Model4_WTime[3]=Model4_ChangeForSave(dispbuf[4]);
1298   1              Model4_WTime[4]=Model4_ChangeForSave(dispbuf[3]);
1299   1              Model4_WTime[5]='\x3A'; //冒号
1300   1              Model4_WTime[6]=Model4_ChangeForSave(dispbuf[1]);
1301   1              Model4_WTime[7]=Model4_ChangeForSave(dispbuf[0]);
1302   1      
1303   1              }
1304          
1305          uchar Model4_ChangeForSave(uchar ucfs){
1306   1      
1307   1              uchar tmp1;
1308   1              tmp1=ucfs;
1309   1              tmp1=word[tmp1];
1310   1              return tmp1;
1311   1      
1312   1      }
1313          
1314          void send_data_from_EEPROM(void){
1315   1      
1316   1      uchar si=0,sj=0;
1317   1      if(Model4_EEPROM_Address>0x21ff){Model4_EEPROM_Address=0x2000;}
1318   1              if(Model4_EEPROM_Address<0x21ff){
1319   2              
1320   2                      IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
1321   2                      while(si<8){
1322   3                      Model4_RTime[si]=EEPROM_read(Model4_EEPROM_Address); 
1323   3      
1324   3                      si++;
1325   3                      Model4_EEPROM_Address++;
1326   3                      }
1327   2                      Model4_RTime[8]='\0';
1328   2              send(Model4_RTime);
1329   2              send("\x20");
1330   2      
1331   2      
1332   2              
1333   2                      while(sj<8){
1334   3                      
1335   3                              Model4_RTem[sj]=EEPROM_read(Model4_EEPROM_Address); 
1336   3                              sj++;
1337   3                              Model4_EEPROM_Address++;
1338   3              
1339   3      }
1340   2              Model4_RTem[8]='\0';
1341   2      send(Model4_RTem);
1342   2      
1343   2      send("\t");
1344   2      send("\t");
1345   2      send("\t");
1346   2      
1347   2      sp++;
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 23  

1348   2      if((sp%3)==0)send("\n");
1349   2      if(sp==9)sp=0;
1350   2              }
1351   1      }
1352          
1353          /****************************模式四按键扫描*****************************************/
1354          uchar Model4_KeyScan(void){
1355   1      
1356   1      Bu_SetZero=1;                   //模式四复用：重新发送
1357   1      Bu_MoveUp=1;                            //模式四复用：开始发送信息
1358   1      Bu_MoveDown=1;                  //模式四复用：停止发送信息
1359   1      Model4_Key=0;
1360   1      
1361   1      if(Bu_MoveUp==0){
1362   2      delay1(5);
1363   2      if(Bu_MoveUp==0)
1364   2      Model4_Key=1;
1365   2      while(Bu_MoveUp==0);
1366   2      }
1367   1      
1368   1      
1369   1      if(Bu_MoveDown==0){
1370   2      delay1(5);
1371   2      if(Bu_MoveDown==0)
1372   2      Model4_Key=2;
1373   2      while(Bu_MoveDown==0);
1374   2      }
1375   1      
1376   1      
1377   1      if(Bu_SetZero==0){
1378   2      delay1(5);
1379   2      if(Bu_SetZero==0)
1380   2      Model4_Key=3;
1381   2      while(Bu_SetZero==0);
1382   2      }
1383   1      
1384   1      return Model4_Key;      
1385   1      }
1386          
1387          void Self_BK_Define4(void){    //用于模式四，显示按键操作
1388   1      
1389   1              uchar  m ;
1390   1          lcd_pos(0) ;                //设置显示位置为第一行的第1个字符
1391   1           m = 0 ;
1392   1          while(cdis7[m]!= '\0')
1393   1           {                         //显示字符
1394   2             lcd_wdat(cdis7[m]) ;
1395   2             m++ ;
1396   2           }
1397   1      
1398   1          lcd_pos(0x40) ;             //设置显示位置为第二行第1个字符
1399   1           m = 0 ;
1400   1          while(Function12[m] != '\0')
1401   1           {
1402   2             lcd_wdat(Function12[m]) ;      //显示字符
1403   2             m++ ;
1404   2           }
1405   1      }
1406          
1407          
1408          
1409          
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 24  

1410          void MainModel4(void){
1411   1      
1412   1      Self_BK_Define4();
1413   1      delay1(600);
1414   1      
1415   1      
1416   1      while(1){
1417   2      
1418   2      Model4_rkey=Model4_KeyScan();
1419   2      
1420   2      if(Model4_rkey==1){
1421   3      while(1){send_data_from_EEPROM();
1422   4      Model4_rkey=Model4_KeyScan();
1423   4      
1424   4      if(Model4_rkey==3){Model4_EEPROM_Address=0x2000;
1425   5      
1426   5      lcd_pos(0x40);
1427   5              m4_n=0;
1428   5              while(Function16[m4_n]!='\0'){
1429   6              lcd_wdat(Function16[m4_n]);
1430   6                              m4_n++;
1431   6                              }
1432   5      delay1(100);
1433   5      
1434   5      }
1435   4      
1436   4      lcd_pos(0x40);
1437   4              m4_n=0;
1438   4              while(Function13[m4_n]!='\0'){
1439   5              lcd_wdat(Function13[m4_n]);
1440   5                              m4_n++;
1441   5                              }
1442   4      if((Model4_rkey==2)||(((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1443   4      //    if(((Menu_INT1)%2)==0)break;      
1444   4                              }
1445   3                              }
1446   2      
1447   2      else if(Model4_rkey==2){
1448   3      
1449   3      while(1){
1450   4      
1451   4      Model4_rkey=Model4_KeyScan();
1452   4      lcd_pos(0x40);
1453   4              m4_n=0;
1454   4              while(Function14[m4_n]!='\0'){
1455   5              lcd_wdat(Function14[m4_n]);
1456   5                              m4_n++;
1457   5                              }
1458   4      if((Model4_rkey==1)||(((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1459   4      //    if(((Menu_INT1)%2)==0)break;              
1460   4      }
1461   3                              }
1462   2      
1463   2      
1464   2      else {
1465   3      lcd_pos(0x40);
1466   3              m4_n=0;
1467   3              while(Function15[m4_n]!='\0'){
1468   4              lcd_wdat(Function15[m4_n]);
1469   4                              m4_n++;
1470   4                              }
1471   3      }
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 25  

1472   2      
1473   2      
1474   2      
1475   2      
1476   2      
1477   2      //    if(((Menu_INT1)%2)==0)break;
1478   2      if((((Menu_INT1)%4)==1)||(((Menu_INT1)%4)==0)||(((Menu_INT1)%4)==2))break;
1479   2      
1480   2      }
1481   1      }
1482          
1483          
1484          
1485          /*****************************************************************/
1486          /*****************************************************************/
1487          /*****************************************************************/
1488          /* 主函数     */
1489          /************************************/
1490          void main(void)
1491           {
1492   1              Ok_Menu();
1493   1              init();
1494   1      
1495   1      /**********************************加入的第3部分****************************************/
1496   1      /****************************************************************************************/
1497   1      SCON=0x50;//串口方式1，允许接收
1498   1         TMOD=0x21;//定时器1，定时方式2
1499   1      // TCON=0x40;//设定时器1开始计数
1500   1      //      ET1=1;
1501   1      //      EA=1;
1502   1       TR1=1;
1503   1              
1504   1         TH1=0xE8;//11.0592MHz, 1200波特率
1505   1         TL1=0xE8;
1506   1         TI=1;
1507   1         TR1=1;
1508   1              IAP_CONTR = ENABLE_ISP; 
1509   1              EEPROM_erase(0x2000);
1510   1              EEPROM_IAP_Disable();
1511   1      
1512   1              /************加入的第3部分结束***********************************************************/
1513   1      
1514   1              while(1){
1515   2              if(((Menu_INT1)%4)==0){
1516   3              MainModel1(); }
1517   2              else if(((Menu_INT1)%4)==1){//  init();
1518   3                      MainModel2(); }
1519   2              else if(((Menu_INT1)%4)==2){
1520   3              PT2262_Data0=1;PT2262_Data1=1;PT2262_Data2=1;PT2262_Data3=1;
1521   3              MainModel3();}
1522   2              else {MainModel4();}
1523   2      }
1524   1      }
1525          
1526                          
1527          /*************************定时器0的中断**********************/
1528          void Time0() interrupt 1 using 2    //再次强调中断子程序执行时间越短越好
1529          {
1530   1       // TH0=(65536-46075)/256;
1531   1       TH0=0x4c;
1532   1        //TL0=(65536-46075)%256;
1533   1        TL0=0x00;
C51 COMPILER V7.00  _____                                                               11/09/2009 22:49:41 PAGE 26  

1534   1        counter++;
1535   1        if(counter==20)
1536   1        {
1537   2          s++;
1538   2        counter=0;
1539   2        if(s==60)
1540   2        { 
1541   3          m++;
1542   3          s=0;
1543   3            if(m==60)
1544   3          {
1545   4            h++;
1546   4          m=0;
1547   4          if(h==24)
1548   4           h=0;
1549   4               }
1550   3             }
1551   2      
1552   2        }
1553   1      }
1554          
1555          
1556          
1557          /*外部中断*/
1558          void int1_Menu_INT1() interrupt 2  
1559                  {
1560   1                      Menu_INT1++;
1561   1                      
1562   1                      if(Menu_INT1==8)Menu_INT1=0;
1563   1              
1564   1              }
1565          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3263    ----
   CONSTANT SIZE    =    454    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     73       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
